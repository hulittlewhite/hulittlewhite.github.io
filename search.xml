<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>校园社区论坛项目之 Spring Security</title>
      <link href="/2023/03/08/community7/"/>
      <url>/2023/03/08/community7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-Security"><a href="#1-Spring-Security" class="headerlink" title="1. Spring Security"></a>1. Spring Security</h1><ul><li> 简介 ：<ul><li>Spring Security 是一个专注于为 Java 应用程序提供身份认证和授权的框架，其强大之处在于可以轻松扩展以满足自定义需求。</li></ul></li><li> 特征：<ul><li> 对身份的认证、授权提供全面的、可扩展的支持。</li><li> 防止各种攻击，如会话固定攻击、点击劫持、CSRF 攻击等。</li><li> 支持与 Servlet API、Spring MVC 等 Web 技术集成。</li></ul></li></ul><h1 id="2- 权限控制"><a href="#2- 权限控制" class="headerlink" title="2. 权限控制"></a>2. 权限控制 </h1><ul><li> 登录检查：<ul><li> 弃用原先采用的拦截器检查用户登录 (过于简单)。</li></ul></li><li> 授权配置：<ul><li> 对当前系统内包含的所有的请求，分配访问权限（普通用户、版主、管理员）。</li></ul></li><li> 认证方案：<ul><li> 绕过 Security 认证流程，采用系统原来的认证方案。</li></ul></li><li>CSRF 配置：<ul><li> 防止 CSRF 攻击的基本原理，以及表单、AJAX 相关的配置。</li></ul></li></ul><h1 id="3- 置顶、加精、删除"><a href="#3- 置顶、加精、删除" class="headerlink" title="3. 置顶、加精、删除"></a>3. 置顶、加精、删除 </h1><ul><li> 功能实现 <ul><li> 点击按钮“置顶”，修改帖子的类型。</li><li> 点击按钮“加精”、“删除”，修改帖子的状态。</li></ul></li><li> 权限管理 <ul><li> 版主可以执行“置顶”、“加精”操作。</li><li> 管理员可以执行“删除”操作。</li></ul></li><li> 按钮显示 <ul><li> 版主可以看到“置顶”、“加精”按钮。</li><li> 管理员可以看到“删除”按钮。</li></ul></li></ul><h1 id="4-Redis- 高级数据类型"><a href="#4-Redis- 高级数据类型" class="headerlink" title="4. Redis 高级数据类型"></a>4. Redis 高级数据类型 </h1><ul><li>HyperLogLog<ul><li> 采用一种基数算法，用于完成独立总数的统计。</li><li> 占据空间小，无论统计多少个数据，只占 12K 的内存空间。</li><li> 不精确的统计算法，标准误差为 0.81% 。</li></ul></li><li>Bitmap<ul><li> 不是一种独立的数据结构，实际上就是字符串。</li><li> 支持按位存取数据，可以将其看成是 byte 数组。</li><li> 适合存储索大量的连续的数据的布尔值。</li></ul></li></ul><h1 id="5- 网站数据统计"><a href="#5- 网站数据统计" class="headerlink" title="5. 网站数据统计"></a>5. 网站数据统计 </h1><ul><li>UV（Unique Visitor） <ul><li> 独立访客，需通过用户 IP 排重统计数据。 </li><li> 每次访问都要进行统计。 </li><li>HyperLogLog ，性能好，且存储空间小。</li></ul></li><li>DAU（Daily Active User） </li><li> 日活跃用户，需通过用户 ID 排重统计数据。 </li><li> 访问过一次，则认为其活跃。 </li><li>Bitmap，性能好、且可以统计精确的结果。</li></ul><h1 id="6- 任务执行和调度"><a href="#6- 任务执行和调度" class="headerlink" title="6. 任务执行和调度"></a>6. 任务执行和调度 </h1><ul><li>JDK 线程池 <ul><li>ExcecutorService </li><li>ScheduledExecutorService</li></ul></li><li>Spring 线程池 <ul><li>ThreadPoolTaskExecutor </li><li>ThreadPoolTaskScheduler</li></ul></li><li> 分布式定时任务 <ul><li>Spring Quartz</li></ul></li></ul><h1 id="7- 热帖排行"><a href="#7- 热帖排行" class="headerlink" title="7. 热帖排行"></a>7. 热帖排行 </h1><ul><li>Hacker News <ul><li>Score &#x3D; (P-1) &#x2F; (T+2) ^ G</li></ul></li><li>StackOverflow <ul><li>(log(Qviews)*4) + ((Qanswers * Qscore)&#x2F;5) + sum(Ascores)</li><li>((QageInHours + 1) - ((QageInHours - Qupdated)&#x2F;2)) ^ 1.5</li></ul></li><li>School<ul><li>log(精华分 + 评论数 * 10 + 点赞数 * 2 + 收藏数 * 2) + (发布时间 – School 纪元)</li></ul></li></ul><h1 id="8- 生成长图"><a href="#8- 生成长图" class="headerlink" title="8. 生成长图"></a>8. 生成长图 </h1><ul><li><p>wkhtmltopdf </p><ul><li>wkhtmltopdf url file </li><li>wkhtmltoimage url file</li></ul></li><li><p>java </p><ul><li>Runtime.getRuntime().exec()</li></ul></li></ul><h1 id="9- 将文件上传至云服务器"><a href="#9- 将文件上传至云服务器" class="headerlink" title="9. 将文件上传至云服务器"></a>9. 将文件上传至云服务器 </h1><ul><li> 客户端上传 <ul><li> 客户端将数据提交给云服务器，并等待其响应。 </li><li> 用户上传头像时，将表单数据提交给云服务器。</li></ul></li><li> 服务器直传 <ul><li> 应用服务器将数据直接提交给云服务器，并等待其响应。 </li><li> 分享时，服务端将自动生成的图片，直接提交给云服务器。</li></ul></li></ul><h1 id="10- 优化网站的性能"><a href="#10- 优化网站的性能" class="headerlink" title="10. 优化网站的性能"></a>10. 优化网站的性能 </h1><ul><li> 本地缓存 <ul><li> 将数据缓存在应用服务器上，性能最好。 </li><li> 常用缓存工具：Ehcache、Guava、Caffeine 等。</li></ul></li><li> 分布式缓存 <ul><li> 将数据缓存在 NoSQL 数据库上，跨服务器。 </li><li> 常用缓存工具：MemCache、Redis 等。</li></ul></li><li> 多级缓存 <ul><li> 一级缓存（本地缓存）&#x3D;&#x3D;&gt; 二级缓存（分布式缓存）&#x3D;&#x3D;&gt; DB </li><li> 避免缓存雪崩（缓存失效，大量请求直达 DB ），提高系统的可用性。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Elasticsearch</title>
      <link href="/2023/03/08/community6/"/>
      <url>/2023/03/08/community6/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Elasticsearch 实现校园社区论坛项目的搜索功能。</p><p>🌟 准备工作：</p><ol><li> 引入 Elasticsearch 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li> 在 application.properties 文件中配置 Elasticsearch 的集群名和节点：</li></ol><pre><code class="properties"># ElasticsearchPropertiesspring.data.elasticsearch.cluster-name=nowcoderspring.data.elasticsearch.cluster-nodes=127.0.0.1:9300</code></pre><ol start="3"><li> 在 CommunityApplication.java 文件中新增方法 <code>init()</code> ：解决 netty 启动冲突。</li></ol><pre><code class="java">@SpringBootApplicationpublic class CommunityApplication &#123;    @PostConstruct    public void init() &#123;        // 解决 netty 启动冲突问题        // see Netty4Utils.setAvailableProcessors()        System.setProperty(&quot;es.set.netty.runtime.available.processors&quot;, &quot;false&quot;);    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(CommunityApplication.class, args);    &#125;&#125;</code></pre><h1 id="1- 建立实体类属性到 -ES- 索引的映射"><a href="#1- 建立实体类属性到 -ES- 索引的映射" class="headerlink" title="1. 建立实体类属性到 ES 索引的映射"></a>1. 建立实体类属性到 ES 索引的映射 </h1><ul><li> 在实体类 DiscussPost 上新增注解 <code>@Document</code></li><li> 将实体类 DiscussPost 的属性与 Elasticsearch 索引建立映射关系。</li></ul><pre><code class="java">@Document(indexName = &quot;discusspost&quot;, type = &quot;_doc&quot;, shards = 6, replicas = 3)public class DiscussPost &#123;    @Id    private int id;    @Field(type = FieldType.Integer)    private int userId;    // 互联网校招    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)    private String title;    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)    private String content;    @Field(type = FieldType.Integer)    private int type;    @Field(type = FieldType.Integer)    private int status;    @Field(type = FieldType.Date)    private Date createTime;    @Field(type = FieldType.Integer)    private int commentCount;    @Field(type = FieldType.Double)    private double score;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public void setUserId(int userId) &#123;        this.userId = userId;    &#125;    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;    public int getType() &#123;        return type;    &#125;    public void setType(int type) &#123;        this.type = type;    &#125;    public int getStatus() &#123;        return status;    &#125;    public void setStatus(int status) &#123;        this.status = status;    &#125;    public Date getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Date createTime) &#123;        this.createTime = createTime;    &#125;    public int getCommentCount() &#123;        return commentCount;    &#125;    public void setCommentCount(int commentCount) &#123;        this.commentCount = commentCount;    &#125;    public double getScore() &#123;        return score;    &#125;    public void setScore(double score) &#123;        this.score = score;    &#125;    @Override    public String toString() &#123;        return &quot;DiscussPost&#123;&quot; +                &quot;id=&quot; + id +                &quot;, userId=&quot; + userId +                &quot;, title=&#39;&quot; + title + &#39;\&#39;&#39; +                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +                &quot;, type=&quot; + type +                &quot;, status=&quot; + status +                &quot;, createTime=&quot; + createTime +                &quot;, commentCount=&quot; + commentCount +                &quot;, score=&quot; + score +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h1 id="2- 创建数据访问层的接口"><a href="#2- 创建数据访问层的接口" class="headerlink" title="2. 创建数据访问层的接口"></a>2. 创建数据访问层的接口 </h1><ul><li> 创建数据访问层的接口 DiscussPostRepository，该接口继承接口 ElasticsearchRepository</li></ul><pre><code class="java">@Repositorypublic interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost, Integer&gt; &#123;&#125;</code></pre><h1 id="3- 访问 -Elasticsearch- 服务器"><a href="#3- 访问 -Elasticsearch- 服务器" class="headerlink" title="3. 访问 Elasticsearch 服务器"></a>3. 访问 Elasticsearch 服务器 </h1><ul><li> 使用 Spring 整合 Elasticsearch，并编写测试代码访问 Elasticsearch 服务器。</li></ul><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = CommunityApplication.class)public class ElasticsearchTests &#123;    @Autowired    private DiscussPostMapper discussMapper;    @Autowired    private DiscussPostRepository discussRepository;    @Autowired    private ElasticsearchTemplate elasticTemplate;    @Test    public void testInsert() &#123;        discussRepository.save(discussMapper.selectDiscussPostById(241));        discussRepository.save(discussMapper.selectDiscussPostById(242));        discussRepository.save(discussMapper.selectDiscussPostById(243));    &#125;    @Test    public void testInsertList() &#123;        discussRepository.saveAll(discussMapper.selectDiscussPosts(101, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(102, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(103, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(111, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(112, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(131, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(132, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(133, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(134, 0, 100));    &#125;    @Test    public void testUpdate() &#123;        DiscussPost post = discussMapper.selectDiscussPostById(231);        post.setContent(&quot;This is some contents.&quot;);        discussRepository.save(post);    &#125;    @Test    public void testDelete() &#123;        // discussRepository.deleteById(231);        discussRepository.deleteAll();    &#125;    @Test    public void testSearchByRepository() &#123;        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(&quot;xx 关键词 &quot;, &quot;title&quot;, &quot;content&quot;))                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .withPageable(PageRequest.of(0, 10))                .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)                ).build();        // elasticTemplate.queryForPage(searchQuery, class, SearchResultMapper)        // 底层获取得到了高亮显示的值, 但是没有返回.        Page&lt;DiscussPost&gt; page = discussRepository.search(searchQuery);        System.out.println(page.getTotalElements());        System.out.println(page.getTotalPages());        System.out.println(page.getNumber());        System.out.println(page.getSize());        for (DiscussPost post : page) &#123;            System.out.println(post);        &#125;    &#125;    @Test    public void testSearchByTemplate() &#123;        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(&quot;xx 关键词 &quot;, &quot;title&quot;, &quot;content&quot;))                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .withPageable(PageRequest.of(0, 10))                .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)                ).build();        Page&lt;DiscussPost&gt; page = elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() &#123;            @Override            public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable) &#123;                SearchHits hits = response.getHits();                if (hits.getTotalHits() &lt;= 0) &#123;                    return null;                &#125;                List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();                for (SearchHit hit : hits) &#123;                    DiscussPost post = new DiscussPost();                    String id = hit.getSourceAsMap().get(&quot;id&quot;).toString();                    post.setId(Integer.valueOf(id));                    String userId = hit.getSourceAsMap().get(&quot;userId&quot;).toString();                    post.setUserId(Integer.valueOf(userId));                    String title = hit.getSourceAsMap().get(&quot;title&quot;).toString();                    post.setTitle(title);                    String content = hit.getSourceAsMap().get(&quot;content&quot;).toString();                    post.setContent(content);                    String status = hit.getSourceAsMap().get(&quot;status&quot;).toString();                    post.setStatus(Integer.valueOf(status));                    String createTime = hit.getSourceAsMap().get(&quot;createTime&quot;).toString();                    post.setCreateTime(new Date(Long.valueOf(createTime)));                    String commentCount = hit.getSourceAsMap().get(&quot;commentCount&quot;).toString();                    post.setCommentCount(Integer.valueOf(commentCount));                    // 处理高亮显示的结果                    HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);                    if (titleField != null) &#123;                        post.setTitle(titleField.getFragments()[0].toString());                    &#125;                    HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);                    if (contentField != null) &#123;                        post.setContent(contentField.getFragments()[0].toString());                    &#125;                    list.add(post);                &#125;                return new AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            &#125;        &#125;);        System.out.println(page.getTotalElements());        System.out.println(page.getTotalPages());        System.out.println(page.getNumber());        System.out.println(page.getSize());        for (DiscussPost post : page) &#123;            System.out.println(post);        &#125;    &#125;&#125;</code></pre><h1 id="4- 开发社区搜索功能"><a href="#4- 开发社区搜索功能" class="headerlink" title="4. 开发社区搜索功能"></a>4. 开发社区搜索功能 </h1><ol><li> 搜索服务：将帖子保存至 Elasticsearch 服务器；从 Elasticsearch 服务器中删除 &#x2F; 搜索帖子。</li><li> 发布事件：发布帖子时，将帖子以异步的方式提交到 Elasticsearch 服务器；增加帖子时，将帖子以异步的方式提交到 Elasticsearch 服务器；在消费组件中新增方法：消费帖子发布事件。</li><li> 显示结果：在 Controller 中处理搜索请求，并在 HTML 页面显示搜索结果。</li></ol><h2 id="4-1- 搜索服务"><a href="#4-1- 搜索服务" class="headerlink" title="4.1 搜索服务"></a>4.1 搜索服务 </h2><ul><li> 创建业务层的 ElasticsearchService 类：<ul><li> 注入 DiscussPostRepository 实例和 ElasticsearchTemplate 示例。</li><li> 新增方法 <code>saveDiscussPost()</code>：保存帖子到 Elasticsearch 服务器。</li><li> 新增方法 <code>deleteDiscussPost()</code>：删除 Elasticsearch 服务器中的帖子。</li><li> 新增方法 <code>searchDiscussPost()</code>：搜索 Elasticsearch 服务器中的帖子。</li></ul></li></ul><pre><code class="java">@Servicepublic class ElasticsearchService &#123;    @Autowired    private DiscussPostRepository discussRepository;    @Autowired    private ElasticsearchTemplate elasticTemplate;    public void saveDiscussPost(DiscussPost post) &#123;        discussRepository.save(post);    &#125;    public void deleteDiscussPost(int id) &#123;        discussRepository.deleteById(id);    &#125;    public Page&lt;DiscussPost&gt; searchDiscussPost(String keyword, int current, int limit) &#123;        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(keyword, &quot;title&quot;, &quot;content&quot;))                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .withPageable(PageRequest.of(current, limit))                .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)                ).build();        return elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() &#123;            @Override            public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable) &#123;                SearchHits hits = response.getHits();                if (hits.getTotalHits() &lt;= 0) &#123;                    return null;                &#125;                List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();                for (SearchHit hit : hits) &#123;                    DiscussPost post = new DiscussPost();                    String id = hit.getSourceAsMap().get(&quot;id&quot;).toString();                    post.setId(Integer.valueOf(id));                    String userId = hit.getSourceAsMap().get(&quot;userId&quot;).toString();                    post.setUserId(Integer.valueOf(userId));                    String title = hit.getSourceAsMap().get(&quot;title&quot;).toString();                    post.setTitle(title);                    String content = hit.getSourceAsMap().get(&quot;content&quot;).toString();                    post.setContent(content);                    String status = hit.getSourceAsMap().get(&quot;status&quot;).toString();                    post.setStatus(Integer.valueOf(status));                    String createTime = hit.getSourceAsMap().get(&quot;createTime&quot;).toString();                    post.setCreateTime(new Date(Long.valueOf(createTime)));                    String commentCount = hit.getSourceAsMap().get(&quot;commentCount&quot;).toString();                    post.setCommentCount(Integer.valueOf(commentCount));                    // 处理高亮显示的结果                    HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);                    if (titleField != null) &#123;                        post.setTitle(titleField.getFragments()[0].toString());                    &#125;                    HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);                    if (contentField != null) &#123;                        post.setContent(contentField.getFragments()[0].toString());                    &#125;                    list.add(post);                &#125;                return new AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            &#125;        &#125;);    &#125;&#125;</code></pre><h2 id="4-2- 发布事件"><a href="#4-2- 发布事件" class="headerlink" title="4.2 发布事件"></a>4.2 发布事件 </h2><ul><li> 更新表现层的 DiscussPostController 类：<ul><li> 更新方法 <code>addDiscussPost()</code>：新增触发发帖事件。</li></ul></li></ul><pre><code class="java">@PostMapping(&quot;/add&quot;)@ResponseBodypublic String addDiscussPost(String title, String content) &#123;    User user = hostHolder.getUser();    if (user == null) &#123;        return CommunityUtil.getJSONString(403, &quot; 你还没有登录哦!&quot;);    &#125;    DiscussPost post = new DiscussPost();    post.setUserId(user.getId());    post.setTitle(title);    post.setContent(content);    post.setCreateTime(new Date());    discussPostService.addDiscussPost(post);    // 触发发帖事件    Event event = new Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(user.getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(post.getId());    eventProducer.fireEvent(event);    // 报错的情况, 将来统一处理.    return CommunityUtil.getJSONString(0, &quot; 发布成功!&quot;);&#125;</code></pre><ul><li> 更新表现层的 CommentController 类：<ul><li> 更新方法 <code>addComment()</code>：新增触发发帖事件。</li></ul></li></ul><pre><code class="java">@PostMapping(&quot;/add/&#123;discussPostId&#125;&quot;)public String addComment(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Comment comment) &#123;    comment.setUserId(hostHolder.getUser().getId());    comment.setStatus(0);    comment.setCreateTime(new Date());    commentService.addComment(comment);    // 触发评论事件    Event event = new Event()            .setTopic(TOPIC_COMMENT)            .setUserId(hostHolder.getUser().getId())            .setEntityType(comment.getEntityType())            .setEntityId(comment.getEntityId())            .setData(&quot;postId&quot;, discussPostId);    if (comment.getEntityType() == ENTITY_TYPE_POST) &#123;        DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125; else if (comment.getEntityType() == ENTITY_TYPE_COMMENT) &#123;        Comment target = commentService.findCommentById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125;    eventProducer.fireEvent(event);    if (comment.getEntityType() == ENTITY_TYPE_POST) &#123;        // 触发发帖事件        event = new Event()                .setTopic(TOPIC_PUBLISH)                .setUserId(comment.getUserId())                .setEntityType(ENTITY_TYPE_POST)                .setEntityId(discussPostId);        eventProducer.fireEvent(event);    &#125;    return &quot;redirect:/discuss/detail/&quot; + discussPostId;&#125;</code></pre><h2 id="4-3- 消费事件"><a href="#4-3- 消费事件" class="headerlink" title="4.3 消费事件"></a>4.3 消费事件 </h2><ul><li> 更新消费组件 EventConsumer 类：<ul><li> 新增方法 <code>handlePublishMessage()</code>：消费帖子发布事件。</li></ul></li></ul><pre><code class="java">// 消费发帖事件@KafkaListener(topics = &#123;TOPIC_PUBLISH&#125;)public void handlePublishMessage(ConsumerRecord record) &#123;    if (record == null || record.value() == null) &#123;        logger.error(&quot; 消息的内容为空!&quot;);        return;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    if (event == null) &#123;        logger.error(&quot; 消息格式错误!&quot;);        return;    &#125;    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());    elasticsearchService.saveDiscussPost(post);&#125;</code></pre><h2 id="4-4- 显示搜索结果"><a href="#4-4- 显示搜索结果" class="headerlink" title="4.4 显示搜索结果"></a>4.4 显示搜索结果 </h2><ul><li> 创建表现层的 SearchController 类：<ul><li> 注入 ElasticsearchService 实例、UserService 实例、LikeService 实例。</li><li> 新增方法 <code>search()</code>：实现帖子搜索 (聚合数据、分页信息) 功能。</li></ul></li></ul><pre><code class="java">@Controllerpublic class SearchController implements CommunityConstant &#123;    @Autowired    private ElasticsearchService elasticsearchService;    @Autowired    private UserService userService;    @Autowired    private LikeService likeService;    // search?keyword=xxx    @RequestMapping(path = &quot;/search&quot;, method = RequestMethod.GET)    public String search(String keyword, Page page, Model model) &#123;        // 搜索帖子        org.springframework.data.domain.Page&lt;DiscussPost&gt; searchResult =                elasticsearchService.searchDiscussPost(keyword, page.getCurrent() - 1, page.getLimit());        // 聚合数据        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;();        if (searchResult != null) &#123;            for (DiscussPost post : searchResult) &#123;                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                // 帖子                map.put(&quot;post&quot;, post);                // 作者                map.put(&quot;user&quot;, userService.findUserById(post.getUserId()));                // 点赞数量                map.put(&quot;likeCount&quot;, likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId()));                discussPosts.add(map);            &#125;        &#125;        model.addAttribute(&quot;discussPosts&quot;, discussPosts);        model.addAttribute(&quot;keyword&quot;, keyword);        // 分页信息        page.setPath(&quot;/search?keyword=&quot; + keyword);        page.setRows(searchResult == null ? 0 : (int) searchResult.getTotalElements());        return &quot;/site/search&quot;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Kafka</title>
      <link href="/2023/03/07/community5/"/>
      <url>/2023/03/07/community5/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Kafka 实现校园社区论坛项目的发送系统通知、显示系统通知的功能。</p><p>🌟 准备工作：</p><ol><li>引入 Kafka 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;        &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在 application.properties 文件中配置 Kafka 的 server 和 consumer：</li></ol><pre><code class="properties"># KafkaPropertiesspring.kafka.bootstrap-servers=localhost:9092spring.kafka.consumer.group-id=community-consumer-groupspring.kafka.consumer.enable-auto-commit=truespring.kafka.consumer.auto-commit-interval=3000</code></pre><ol start="3"><li>访问 Kafka：</li></ol><p>生产者</p><pre><code>kafkaTemplate.send(topic, data);</code></pre><p>消费者</p><pre><code>@KafkaListener(topic = &#123;&quot;test&quot;&#125;)</code></pre><pre><code>public void handleMessage(ConsumerRecord record)&#123;&#125;</code></pre><h1 id="1- 发送系统通知"><a href="#1- 发送系统通知" class="headerlink" title="1. 发送系统通知"></a>1. 发送系统通知</h1><ol><li>触发事件：评论后发布通知；点赞后发布通知；关注后发布通知。</li><li>处理事件：封装事件对象；开发事件的生产者；开发事件的消费者。</li></ol><h2 id="创建实体类 -Event"><a href="# 创建实体类 -Event" class="headerlink" title="创建实体类 Event"></a>创建实体类 Event</h2><ul><li>封装事件对象，包括主题、用户 id、实体类型、实体 id、实体用户 id 以及一个 map 集合存放其它信息。</li></ul><pre><code class="java">public class Event &#123;    private String topic;    private int userId;    private int entityType;    private int entityId;    private int entityUserId;    private Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();    public String getTopic() &#123;        return topic;    &#125;    public Event setTopic(String topic) &#123;        this.topic = topic;        return this;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public Event setUserId(int userId) &#123;        this.userId = userId;        return this;    &#125;    public int getEntityType() &#123;        return entityType;    &#125;    public Event setEntityType(int entityType) &#123;        this.entityType = entityType;        return this;    &#125;    public int getEntityId() &#123;        return entityId;    &#125;    public Event setEntityId(int entityId) &#123;        this.entityId = entityId;        return this;    &#125;    public int getEntityUserId() &#123;        return entityUserId;    &#125;    public Event setEntityUserId(int entityUserId) &#123;        this.entityUserId = entityUserId;        return this;    &#125;    public Map&lt;String, Object&gt; getData() &#123;        return data;    &#125;    public Event setData(String key, Object value) &#123;        this.data.put(key, value);        return this;    &#125;&#125;</code></pre><h2 id="更新接口 -CommunityConstant"><a href="# 更新接口 -CommunityConstant" class="headerlink" title="更新接口 CommunityConstant"></a>更新接口 CommunityConstant</h2><ul><li>在接口中新增三个常量，代表三个主题：评论、点赞、关注。</li></ul><pre><code class="java">/** * 主题: 评论 */String TOPIC_COMMENT = &quot;comment&quot;;/** * 主题: 点赞 */String TOPIC_LIKE = &quot;like&quot;;/** * 主题: 关注 */String TOPIC_FOLLOW = &quot;follow&quot;;</code></pre><h2 id="创建事件生产者类 -EventProducer"><a href="# 创建事件生产者类 -EventProducer" class="headerlink" title="创建事件生产者类 EventProducer"></a>创建事件生产者类 EventProducer</h2><ul><li>新增方法 <code>fireEvent(Event event)</code> ：通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的方法 <code>send()</code> 发送。</li></ul><pre><code class="java">@Componentpublic class EventProducer &#123;    @Autowired    private KafkaTemplate kafkaTemplate;    // 处理事件    public void fireEvent(Event event) &#123;        // 将事件发布到指定的主题        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));    &#125;&#125;</code></pre><h2 id="更新表现层的 -CommentController、LikeController、FollowController"><a href="# 更新表现层的 -CommentController、LikeController、FollowController" class="headerlink" title="更新表现层的 CommentController、LikeController、FollowController"></a>更新表现层的 CommentController、LikeController、FollowController</h2><ul><li>注入 EventProducer 实例。</li><li>重构表现层 CommentController 类的方法 <code>addComment()</code>  ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/add/&#123;discussPostId&#125;&quot;)public String addComment(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Comment comment) &#123;    comment.setUserId(hostHolder.getUser().getId());    comment.setStatus(0);    comment.setCreateTime(new Date());    commentService.addComment(comment);    // 触发评论事件    Event event = new Event()            .setTopic(TOPIC_COMMENT)            .setUserId(hostHolder.getUser().getId())            .setEntityType(comment.getEntityType())            .setEntityId(comment.getEntityId())            .setData(&quot;postId&quot;, discussPostId);    if (comment.getEntityType() == ENTITY_TYPE_POST) &#123;        DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125; else if (comment.getEntityType() == ENTITY_TYPE_COMMENT) &#123;        Comment target = commentService.findCommentById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125;    eventProducer.fireEvent(event);    return &quot;redirect:/discuss/detail/&quot; + discussPostId;&#125;</code></pre><ul><li>重构表现层 LikeController 类的方法 <code>like()</code>  ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/like&quot;)@ResponseBodypublic String like(int entityType, int entityId, int entityUserId, int postId) &#123;    User user = hostHolder.getUser();    // 点赞    likeService.like(user.getId(), entityType, entityId, entityUserId);    // 数量    long likeCount = likeService.findEntityLikeCount(entityType, entityId);    // 状态    int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);    // 返回的结果    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;likeCount&quot;, likeCount);    map.put(&quot;likeStatus&quot;, likeStatus);    // 触发点赞事件    if (likeStatus == 1) &#123;        Event event = new Event()                .setTopic(TOPIC_LIKE)                .setUserId(hostHolder.getUser().getId())                .setEntityType(entityType)                .setEntityId(entityId)                .setEntityUserId(entityUserId)                .setData(&quot;postId&quot;, postId);        eventProducer.fireEvent(event);    &#125;    return CommunityUtil.getJSONString(0, null, map);&#125;</code></pre><ul><li>重构表现层 FollowController 类的方法 <code>follow()</code> ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/follow&quot;)@ResponseBodypublic String follow(int entityType, int entityId) &#123;    User user = hostHolder.getUser();    followService.follow(user.getId(), entityType, entityId);    // 触发关注事件    Event event = new Event()            .setTopic(TOPIC_FOLLOW)            .setUserId(hostHolder.getUser().getId())            .setEntityType(entityType)            .setEntityId(entityId)            .setEntityUserId(entityId);    eventProducer.fireEvent(event);    return CommunityUtil.getJSONString(0, &quot; 已关注!&quot;);&#125;</code></pre><h2 id="创建事件消费者类 -EventConsumer"><a href="# 创建事件消费者类 -EventConsumer" class="headerlink" title="创建事件消费者类 EventConsumer"></a>创建事件消费者类 EventConsumer</h2><ul><li>注入 MessageService 实例。</li><li>新增方法 <code>handleCommentMessage(ConsumerRecord record)</code> ：通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 record 中获取信息，封装成 Message 对象然后调用方法 <code>addMessage()</code> 插入数据库。</li></ul><pre><code class="java">@Componentpublic class EventConsumer implements CommunityConstant &#123;    private static final Logger logger = LoggerFactory.getLogger(EventConsumer.class);    @Autowired    private MessageService messageService;    @KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)    public void handleCommentMessage(ConsumerRecord record) &#123;        if (record == null || record.value() == null) &#123;            logger.error(&quot; 消息的内容为空!&quot;);            return;        &#125;        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) &#123;            logger.error(&quot; 消息格式错误!&quot;);            return;        &#125;        // 发送站内通知        Message message = new Message();        message.setFromId(SYSTEM_USER_ID);        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        message.setCreateTime(new Date());        Map&lt;String, Object&gt; content = new HashMap&lt;&gt;();        content.put(&quot;userId&quot;, event.getUserId());        content.put(&quot;entityType&quot;, event.getEntityType());        content.put(&quot;entityId&quot;, event.getEntityId());        if (!event.getData().isEmpty()) &#123;            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;                content.put(entry.getKey(), entry.getValue());            &#125;        &#125;        message.setContent(JSONObject.toJSONString(content));        messageService.addMessage(message);    &#125;&#125;</code></pre><h1 id="2- 显示系统通知"><a href="#2- 显示系统通知" class="headerlink" title="2. 显示系统通知"></a>2. 显示系统通知</h1><ol><li>通知列表：显示评论、点赞、关注三种类型的通知。</li><li>通知详情：分页显示某一类主题所包含的通知。</li><li>未读消息：在页面头部显示所有未读消息的数量。</li></ol><h2 id="更新接口 -MessageMapper"><a href="# 更新接口 -MessageMapper" class="headerlink" title="更新接口 MessageMapper"></a>更新接口 MessageMapper</h2><ul><li>新增方法 <code>selectLatestNotice(int userId, String topic)</code> ，查询某主题最新的通知。</li><li>新增方法 <code>selectNoticeCount(int userId, String topic)</code> ，查询某主题通知的数量。</li><li>新增方法 <code>selectNoticeUnreadCount(int userId, String topic)</code> ，查询未读通知的数量。</li></ul><pre><code class="java">// 查询某个主题下最新的通知Message selectLatestNotice(int userId, String topic);// 查询某个主题所包含的通知数量int selectNoticeCount(int userId, String topic);// 查询未读的通知的数量int selectNoticeUnreadCount(int userId, String topic);</code></pre><ul><li>在 <code>message-mapper.xml</code> 配置三个方法的 sql 语句，其中查询未读通知时使用 if 动态语句，如果没有传入 topic 就查询未读总量。</li></ul><pre><code class="xml">&lt;sql id=&quot;selectFields&quot;&gt;    id, from_id, to_id, conversation_id, content, status, create_time&lt;/sql&gt;&lt;select id=&quot;selectLatestNotice&quot; resultType=&quot;Message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where id in (select max(id) from message        where status != 2        and from_id = 1        and to_id = #&#123;userId&#125;        and conversation_id = #&#123;topic&#125;    )&lt;/select&gt;&lt;select id=&quot;selectNoticeCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;&lt;/select&gt;&lt;select id=&quot;selectNoticeUnreadCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status = 0    and from_id = 1    and to_id = #&#123;userId&#125;    &lt;if test=&quot;topic!=null&quot;&gt;        and conversation_id = #&#123;topic&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre><h2 id="更新业务层的 -MessageService- 类"><a href="# 更新业务层的 -MessageService- 类" class="headerlink" title="更新业务层的 MessageService 类"></a>更新业务层的 MessageService 类</h2><ul><li>新增方法 <code>findLatestNotice()</code> ，调用方法 <code>selectLatestNotice()</code> 查询最新通知。</li><li>新增方法 <code>findNoticeCount()</code> ，调用方法 <code>selectNoticeCount()</code> 查询某主题通知的数量。</li><li>新增方法 <code>findNoticeUnreadCount()</code> ，调用方法 <code>selectNoticeUnreadCount()</code> 查询未读通知的数量。</li></ul><pre><code class="java">public Message findLatestNotice(int userId, String topic) &#123;    return messageMapper.selectLatestNotice(userId, topic);&#125;public int findNoticeCount(int userId, String topic) &#123;    return messageMapper.selectNoticeCount(userId, topic);&#125;public int findNoticeUnreadCount(int userId, String topic) &#123;    return messageMapper.selectNoticeUnreadCount(userId, topic);&#125;</code></pre><h2 id="更新表现层的 -MessageController- 类"><a href="# 更新表现层的 -MessageController- 类" class="headerlink" title="更新表现层的 MessageController 类"></a>更新表现层的 MessageController 类</h2><ul><li>新增方法 <code>getNoticeList()</code> ：获取通知列表。<ul><li>调用业务层的 MessageService 类的方法查询评论、点赞、关注的通知，将其封装在一个 HashMap 集合中然后添加到 Model 对象中。</li><li>调用业务层的 MessageService 类的方法查询私信和通知的总未读数量，添加到 Model 对象中。</li><li>返回 <code>notice.html</code> 页面。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/notice/list&quot;)public String getNoticeList(Model model) &#123;    User user = hostHolder.getUser();    // 查询评论类通知    Message message = messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);    Map&lt;String, Object&gt; messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;commentNotice&quot;, messageVO);    // 查询点赞类通知    message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);    messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_LIKE);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;likeNotice&quot;, messageVO);    // 查询关注类通知    message = messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);    messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;followNotice&quot;, messageVO);    // 查询私信的总未读数    int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);    model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);      // 查询通知的总未读数    int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);    model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);    return &quot;/site/notice&quot;;&#125;</code></pre><h2 id="再次更新接口 -MessageMapper"><a href="# 再次更新接口 -MessageMapper" class="headerlink" title="再次更新接口 MessageMapper"></a>再次更新接口 MessageMapper</h2><ul><li>新增方法 <code>selectNotices()</code> ：查询某个主题的通知列表。</li><li>在 <code>message-mapper.xml</code> 文件中配置 SQL。</li></ul><pre><code class="java">// 查询某个主题所包含的通知列表List&lt;Message&gt; selectNotices(int userId, String topic, int offset, int limit);</code></pre><pre><code class="xml">&lt;select id=&quot;selectNotices&quot; resultType=&quot;Message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;    order by create_time desc    limit #&#123;offset&#125;, #&#123;limit&#125;&lt;/select&gt;</code></pre><h2 id="再次更新业务层的 -MessageService- 类"><a href="# 再次更新业务层的 -MessageService- 类" class="headerlink" title="再次更新业务层的 MessageService 类"></a>再次更新业务层的 MessageService 类 </h2><p> 新增方法 <code>findNotices()</code> ：调用方法 <code>selectNotices()</code> 。</p><pre><code class="java">public List&lt;Message&gt; findNotices(int userId, String topic, int offset, int limit) &#123;    return messageMapper.selectNotices(userId, topic, offset, limit);&#125;</code></pre><h2 id="再次更新业务层的 -MessageController- 类"><a href="# 再次更新业务层的 -MessageController- 类" class="headerlink" title="再次更新业务层的 MessageController 类"></a>再次更新业务层的 MessageController 类</h2><ul><li>新增方法 <code>getNoticeDetail()</code> ：<ul><li>调用方法 <code>findNotices()</code> 获取通知列表详情，封装到 List 集合并存入 Model 对象。</li><li>从通知集合中获取 id 集合，调用方法 <code>readMessage()</code> 将消息设为已读。</li><li>返回 <code>notice-detail.html</code> 页面。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/notice/detail/&#123;topic&#125;&quot;)public String getNoticeDetail(@PathVariable(&quot;topic&quot;) String topic, Page page, Model model) &#123;    User user = hostHolder.getUser();    page.setLimit(5);    page.setPath(&quot;/notice/detail/&quot; + topic);    page.setRows(messageService.findNoticeCount(user.getId(), topic));    List&lt;Message&gt; noticeList = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; noticeVoList = new ArrayList&lt;&gt;();    if (noticeList != null) &#123;        for (Message notice : noticeList) &#123;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            // 通知            map.put(&quot;notice&quot;, notice);            // 内容            String content = HtmlUtils.htmlUnescape(notice.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            map.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));            map.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));            map.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));            map.put(&quot;postId&quot;, data.get(&quot;postId&quot;));            // 通知作者            map.put(&quot;fromUser&quot;, userService.findUserById(notice.getFromId()));            noticeVoList.add(map);        &#125;    &#125;    model.addAttribute(&quot;notices&quot;, noticeVoList);    // 设置已读    List&lt;Integer&gt; ids = getLetterIds(noticeList);    if (!ids.isEmpty()) &#123;        messageService.readMessage(ids);    &#125;    return &quot;/site/notice-detail&quot;;&#125;</code></pre><h2 id="创建表现层的拦截器 -MessageInterceptor- 类"><a href="# 创建表现层的拦截器 -MessageInterceptor- 类" class="headerlink" title="创建表现层的拦截器 MessageInterceptor 类"></a>创建表现层的拦截器 MessageInterceptor 类</h2><ul><li>注入 MessageService 实例和 HostHolder 实例。</li><li>重写方法 <code>postHandle()</code> ，查询私信和通知的未读数量和，然后添加到 ModelAndView 对象。</li></ul><pre><code class="java">@Componentpublic class MessageInterceptor implements HandlerInterceptor &#123;    @Autowired    private HostHolder hostHolder;    @Autowired    private MessageService messageService;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        User user = hostHolder.getUser();        if (user != null &amp;&amp; modelAndView != null) &#123;            int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);            int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);            modelAndView.addObject(&quot;allUnreadCount&quot;, letterUnreadCount + noticeUnreadCount);        &#125;    &#125;&#125;</code></pre><h2 id="更新配置类 -WebConfig"><a href="# 更新配置类 -WebConfig" class="headerlink" title="更新配置类 WebConfig"></a>更新配置类 WebConfig</h2><ul><li>注入 MessageInterceptor 实例。</li><li>在方法 <code>addInterceptors()</code> 中添加拦截器 MessageInterceptor 实例。</li></ul><pre><code class="java">@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(alphaInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;)            .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;);    registry.addInterceptor(loginTicketInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    registry.addInterceptor(loginRequiredInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    registry.addInterceptor(messageInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Redis</title>
      <link href="/2023/03/07/community4/"/>
      <url>/2023/03/07/community4/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Redis 实现校园社区论坛项目的点赞、关注功能，同时优化了登录模块中的验证码存储、登录凭证存储、用户信息缓存功能。</p><p>🌟 准备工作：</p><ol><li>引入 Redis 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在 application.properties 文件中配置 Redis：</li></ol><pre><code class="properties"># RedisPropertiesspring.redis.database=11spring.redis.host=localhostspring.redis.port=6379</code></pre><ol start="3"><li>编写配置类 RedisConfig：</li></ol><pre><code class="java">@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        // 设置 key 的序列化方式        template.setKeySerializer(RedisSerializer.string());        // 设置 value 的序列化方式        template.setValueSerializer(RedisSerializer.json());        // 设置 hash 的 key 的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        // 设置 hash 的 value 的序列化方式        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        return template;    &#125;&#125;</code></pre><h1 id="1- 点赞模块"><a href="#1- 点赞模块" class="headerlink" title="1. 点赞模块"></a>1. 点赞模块 </h1><p> 点赞模块包含：</p><ol><li>点赞：(1) 支持对帖子、评论进行点赞；(2) 第一次点击“赞”完成点赞操作，第二次点击“已赞”完成取消点赞操作。</li><li>首页：统计帖子的点赞数。</li><li>详情页：(1) 统计帖子的点赞数；(2) 显示点赞状态。</li></ol><h2 id="创建工具类 -RedisKeyUtil"><a href="# 创建工具类 -RedisKeyUtil" class="headerlink" title="创建工具类 RedisKeyUtil"></a>创建工具类 RedisKeyUtil</h2><ul><li>定义分隔符 <code>:</code></li><li>定义实体获得赞的 key 前缀常量  <code>like:entity</code></li><li>新增方法 <code>getEntityLikeKey(int entityType, int entityId)</code>，通过实体类型和实体 id 生成对应实体获得赞的 key，这个 key 的呈现形式为 <code>like:entity:entityType:entityId</code>。</li></ul><pre><code class="jade">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;&#125;</code></pre><h2 id="创建业务层的 -LikeService- 类"><a href="# 创建业务层的 -LikeService- 类" class="headerlink" title="创建业务层的 LikeService 类"></a>创建业务层的 LikeService 类</h2><ul><li>注入 <code>RedisTemplate</code> 实例</li></ul><pre><code class="java">@Autowiredprivate RedisTemplate redisTemplate;</code></pre><ul><li>新增方法 <code>like()</code> 实现点赞功能：<ul><li>首先，调用工具类 <code>RedisKeyUtil</code> 中的方法 <code>getEntityLikeKey()</code> 获得实体点赞的 key；</li><li>然后，通过 <code>RedisTemplate</code> 实例，调用 set 集合的方法 <code>isMember()</code> 查询 userId 是否存在于对应 key 的 set 集合中，如果存在则移出点赞的用户集合，如果不存在则添加到点赞的用户集合中。</li></ul></li></ul><pre><code class="java"> // 点赞public void like(int userId, int entityType, int entityId) &#123;    String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);    boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);      // 判断是否点过赞    if (isMember) &#123;        redisTemplate.opsForSet().remove(entityLikeKey, userId);    &#125; else &#123;        redisTemplate.opsForSet().add(entityLikeKey, userId);    &#125;&#125;</code></pre><ul><li>新增方法 <code>findEntityLikeCount()</code>：查询某实体的点赞数，通过调用 set 集合的方法 <code>size()</code> 查询元素的个数。</li></ul><pre><code class="java">// 查询某实体点赞的数量public long findEntityLikeCount(int entityType, int entityId) &#123;    String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);    return redisTemplate.opsForSet().size(entityLikeKey);&#125;</code></pre><ul><li>新增方法 <code>findEntityLikeStatus()</code>：查询某用户对某实体的点赞状态，逻辑实现同方法 <code>like()</code>，即通过调用 set 集合的方法 <code>isMember()</code> 实现。</li></ul><pre><code class="java">// 查询某人对某实体的点赞状态public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;    String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);    // 1 表示已赞；0 表示未赞    return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;&#125;</code></pre><h2 id="创建表现层的 -LikeController- 类"><a href="# 创建表现层的 -LikeController- 类" class="headerlink" title="创建表现层的 LikeController 类"></a>创建表现层的 LikeController 类</h2><ul><li>注入 <code>LikeService</code> 和 <code>HostHolder</code> 实例</li><li>新增方法 <code>like()</code>：实现点赞功能，调用业务层的方法 <code>like()</code> 进行点赞，调用 <code>findEntityLikeCount()</code> 和 <code>findEntityLikeStatus()</code> 查询点赞数和点赞状态，并封装到 map 集合中，然后通过工具类封装成 JSON 数据返回。</li></ul><pre><code class="java">@Controllerpublic class LikeController &#123;    @Autowired    private LikeService likeService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/like&quot;)    @ResponseBody    public String like(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        // 点赞        likeService.like(user.getId(), entityType, entityId);        // 数量        long likeCount = likeService.findEntityLikeCount(entityType, entityId);        // 状态        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        // 返回的结果        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;, likeCount);        map.put(&quot;likeStatus&quot;, likeStatus);        return CommunityUtil.getJSONString(0, null, map);    &#125;&#125;</code></pre><h2 id="更新表现层的 -HomeController- 类"><a href="# 更新表现层的 -HomeController- 类" class="headerlink" title="更新表现层的 HomeController 类"></a>更新表现层的 HomeController 类</h2><ul><li><p>注入  <code>LikeService</code> 实例</p></li><li><p>更新方法  <code>getIndexPage()</code>：新增更新首页帖子点赞数功能，调用业务层的 <code>LikeService</code> 类的方法获得点赞数，并存储到 map 集合中。</p></li></ul><pre><code class="java">@GetMapping(&quot;/index&quot;)public String getIndexPage(Model model, Page page) &#123;    // 方法调用之前，SpringMVC 会自动实例化 Model 和 Page，并将 Page 注入到 Model 中。    // 所以，在 thymeleaf 中可以直接访问 Page 对象中的数据。    page.setRows(discussPostService.findDiscussPostRows(0));    page.setPath(&quot;/index&quot;);    List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;();    if (list != null) &#123;        for (DiscussPost post : list) &#123;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;post&quot;, post);            User user = userService.findUserById(post.getUserId());            map.put(&quot;user&quot;, user);            long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());            map.put(&quot;likeCount&quot;, likeCount);            discussPosts.add(map);        &#125;    &#125;    model.addAttribute(&quot;discussPosts&quot;, discussPosts);    return &quot;/index&quot;;&#125;</code></pre><h2 id="更新表现层的 -DiscussPostController- 类"><a href="# 更新表现层的 -DiscussPostController- 类" class="headerlink" title="更新表现层的 DiscussPostController 类"></a>更新表现层的 DiscussPostController 类</h2><ul><li>注入  <code>LikeService</code> 实例</li><li>更新方法 <code>addDiscussPost()</code>：新增更新详情页帖子（评论、回复）的点赞数功能，调用业务层的 <code>LikeService</code> 类的方法获得点赞数和点赞状态，并将其存入视图对象中。</li></ul><pre><code class="java">@GetMapping(&quot;/detail/&#123;discussPostId&#125;&quot;)public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) &#123;    // 帖子    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);    model.addAttribute(&quot;post&quot;, post);    // 作者    User user = userService.findUserById(post.getUserId());    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    // 点赞状态    int likeStatus = hostHolder.getUser() == null ? 0 :            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);    model.addAttribute(&quot;likeStatus&quot;, likeStatus);    // 评论分页信息    page.setLimit(5);    page.setPath(&quot;/discuss/detail/&quot; + discussPostId);    page.setRows(post.getCommentCount());    // 评论: 给帖子的评论    // 回复: 给评论的评论    // 评论列表    List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());    // 评论 VO 列表    List&lt;Map&lt;String, Object&gt;&gt; commentVoList = new ArrayList&lt;&gt;();    if (commentList != null) &#123;        for (Comment comment : commentList) &#123;            // 评论 VO            Map&lt;String, Object&gt; commentVo = new HashMap&lt;&gt;();            // 评论            commentVo.put(&quot;comment&quot;, comment);            // 作者            commentVo.put(&quot;user&quot;, userService.findUserById(comment.getUserId()));            // 点赞数量            likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;likeCount&quot;, likeCount);            // 点赞状态            likeStatus = hostHolder.getUser() == null ? 0 :                    likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;likeStatus&quot;, likeStatus);            // 回复列表            List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);            // 回复 VO 列表            List&lt;Map&lt;String, Object&gt;&gt; replyVoList = new ArrayList&lt;&gt;();            if (replyList != null) &#123;                for (Comment reply : replyList) &#123;                    Map&lt;String, Object&gt; replyVo = new HashMap&lt;&gt;();                    // 回复                    replyVo.put(&quot;reply&quot;, reply);                    // 作者                    replyVo.put(&quot;user&quot;, userService.findUserById(reply.getUserId()));                    // 回复目标                    User target = reply.getTargetId() == 0 ? null : userService.findUserById(reply.getTargetId());                    replyVo.put(&quot;target&quot;, target);                    // 点赞数量                    likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());                    replyVo.put(&quot;likeCount&quot;, likeCount);                    // 点赞状态                    likeStatus = hostHolder.getUser() == null ? 0 :                            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());                    replyVo.put(&quot;likeStatus&quot;, likeStatus);                    replyVoList.add(replyVo);                &#125;            &#125;            commentVo.put(&quot;replys&quot;, replyVoList);            // 回复数量            int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;replyCount&quot;, replyCount);            commentVoList.add(commentVo);        &#125;    &#125;    model.addAttribute(&quot;comments&quot;, commentVoList);    return &quot;/site/discuss-detail&quot;;&#125;</code></pre><h1 id="2- 收到的赞"><a href="#2- 收到的赞" class="headerlink" title="2. 收到的赞"></a>2. 收到的赞</h1><ol><li>重构点赞功能：以用户为 key，记录点赞数量；<code>increment(key)</code>、<code>decrement(key)</code></li><li>开发个人主页：以用户为 key，查询点赞数。</li></ol><h2 id="更新工具类 -RedisUtil"><a href="# 更新工具类 -RedisUtil" class="headerlink" title="更新工具类 RedisUtil"></a>更新工具类 RedisUtil</h2><ul><li><p>新增用户获得赞 key 的前缀常量 <code>like:user</code></p></li><li><p>新增方法 <code>getUserLikeKey(int userId)</code>，通过用户 id 生成对应用户获得赞的 key。</p></li></ul><pre><code class="java">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    private static final String PREFIX_USER_LIKE = &quot;like:user&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;    // 某个用户的赞    // like:user:userId -&gt; int    public static String getUserLikeKey(int userId) &#123;        return PREFIX_USER_LIKE + SPLIT + userId;    &#125;&#125;</code></pre><h2 id="更新业务层的 -LikeService 类"><a href="# 更新业务层的 -LikeService 类" class="headerlink" title="更新业务层的 LikeService 类"></a>更新业务层的 LikeService 类</h2><ul><li>重构方法 <code>like()</code>，在参数列表中新增：entityUserId（表示被点赞用户的 id），该参数用来更新用户的被点赞数量。<ul><li>调用 <code>RedisTemplate</code> 实例的方法 <code>execute()</code> 实现事务，保证被点赞用户与点赞用户的数据更新保持一致。调用 <code>isMember()</code> 查询用户的点赞状态，之后调用 <code>multi()</code> 开启事务。</li><li>当用户已点赞时，调用方法 <code>remove()</code> 将当前用户从点赞的用户集合中移除，调用方法 <code>decrement()</code> 将被点赞用户的被点赞数减去 1；当用户未点赞时，调用方法 <code>add()</code> 将当前用户添加到点赞的用户集合中，调用方法 <code>increment()</code> 将被点赞用户的点赞数加上 1。</li></ul></li><li>新增方法 <code>findUserLikeCount()</code>，以用户 id 为 key，调用方法 <code>get()</code> 查询用户所获点赞数。</li></ul><pre><code class="java">@Servicepublic class LikeService &#123;    @Autowired    private RedisTemplate redisTemplate;    // 点赞    public void like(int userId, int entityType, int entityId, int entityUserId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);                boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);                operations.multi();                if (isMember) &#123;                    operations.opsForSet().remove(entityLikeKey, userId);                    operations.opsForValue().decrement(userLikeKey);                &#125; else &#123;                    operations.opsForSet().add(entityLikeKey, userId);                    operations.opsForValue().increment(userLikeKey);                &#125;                return operations.exec();            &#125;        &#125;);    &#125;    // 查询某实体点赞的数量    public long findEntityLikeCount(int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().size(entityLikeKey);    &#125;    // 查询某人对某实体的点赞状态    public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;    &#125;    // 查询某个用户获得的赞    public int findUserLikeCount(int userId) &#123;        String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);        Integer count = (Integer) redisTemplate.opsForValue().get(userLikeKey);        return count == null ? 0 : count.intValue();    &#125;&#125;</code></pre><h2 id="更新表现层的 -LikeController- 类"><a href="# 更新表现层的 -LikeController- 类" class="headerlink" title="更新表现层的 LikeController 类"></a>更新表现层的 LikeController 类</h2><ul><li>更新方法 <code>like()</code>：在参数列表中新增参数 entityUserId（表示被点赞用户的 id）。</li></ul><pre><code class="java">@Controllerpublic class LikeController &#123;    @Autowired    private LikeService likeService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/like&quot;)    @ResponseBody    public String like(int entityType, int entityId, int entityUserId) &#123;        User user = hostHolder.getUser();        // 点赞        likeService.like(user.getId(), entityType, entityId, entityUserId);        // 数量        long likeCount = likeService.findEntityLikeCount(entityType, entityId);        // 状态        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        // 返回的结果        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;, likeCount);        map.put(&quot;likeStatus&quot;, likeStatus);        return CommunityUtil.getJSONString(0, null, map);    &#125;&#125;</code></pre><h2 id="更新表现层的 -UserController- 类"><a href="# 更新表现层的 -UserController- 类" class="headerlink" title="更新表现层的 UserController 类"></a>更新表现层的 UserController 类</h2><ul><li>新增方法<code>getProfilePage()</code>：调用业务层的方法查询用户和点赞数，并将两项信息存储于 Model 对象中。</li></ul><pre><code class="java">// 个人主页@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)public String getProfilePage(@PathVariable(&quot;userId&quot;) int userId, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    // 用户    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    int likeCount = likeService.findUserLikeCount(userId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    return &quot;/site/profile&quot;;&#125;</code></pre><h1 id="3- 关注"><a href="#3- 关注" class="headerlink" title="3. 关注"></a>3. 关注 </h1><h2 id="更新工具类 -RedisUtil-1"><a href="# 更新工具类 -RedisUtil-1" class="headerlink" title="更新工具类 RedisUtil"></a> 更新工具类 RedisUtil</h2><ul><li>新增用户关注实体（帖子、评论、用户等）的前缀常量 followee 和粉丝（用户）的前缀常量 follower。</li><li>新增方法 <code>getFolloweeKey(int userId, int entityType)</code>，通过用户 id 和实体类型生成用户关注实体的 key。</li><li>新增方法 <code>getFollowerKey(int entityType, int entityId)</code>，通过实体类型和实体 id 生成实体用户粉丝的 key。</li></ul><pre><code class="java">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    private static final String PREFIX_USER_LIKE = &quot;like:user&quot;;    private static final String PREFIX_FOLLOWEE = &quot;followee&quot;;    private static final String PREFIX_FOLLOWER = &quot;follower&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;    // 某个用户的赞    // like:user:userId -&gt; int    public static String getUserLikeKey(int userId) &#123;        return PREFIX_USER_LIKE + SPLIT + userId;    &#125;    // 某个用户关注的实体    // followee:userId:entityType -&gt; zset(entityId,now)    public static String getFolloweeKey(int userId, int entityType) &#123;        return PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;    &#125;    // 某个实体拥有的粉丝    // follower:entityType:entityId -&gt; zset(userId,now)    public static String getFollowerKey(int entityType, int entityId) &#123;        return PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;    &#125;&#125;</code></pre><h2 id="创建业务层的 -FollowService- 类"><a href="# 创建业务层的 -FollowService- 类" class="headerlink" title="创建业务层的 FollowService 类"></a>创建业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>follow()</code>，当用户关注某实体时：</p><ul><li>调用方法 <code>add() </code>将当前实体 id 和时间作为 value 和 score 加入到用户的关注集合中。</li><li>调用方法 <code>add()</code> 将当前用户 id 和时间作为 value 和 score 加入到实体的粉丝集合中。</li></ul></li><li><p>新增方法 <code>unfollow()</code>，当用户取关某实体时：</p><ul><li>调用方法 <code>remove()</code> 将当前实体从用户的关注集合中移除。</li><li>调用方法 <code>remove()</code> 将用户从实体的粉丝集合中移除。</li></ul></li></ul><pre><code class="java">@Servicepublic class FollowService &#123;    @Autowired    private RedisTemplate redisTemplate;    public void follow(int userId, int entityType, int entityId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                operations.multi();                operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());                operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());                return operations.exec();            &#125;        &#125;);    &#125;    public void unfollow(int userId, int entityType, int entityId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                operations.multi();                operations.opsForZSet().remove(followeeKey, entityId);                operations.opsForZSet().remove(followerKey, userId);                return operations.exec();            &#125;        &#125;);    &#125;&#125;</code></pre><h2 id="创建表现层的 -FollowController"><a href="# 创建表现层的 -FollowController" class="headerlink" title="创建表现层的 FollowController"></a>创建表现层的 FollowController</h2><ul><li>新增方法 <code>follow()</code>：调用 HostHolder 对象的方法获取用户，调用业务层的 <code>FollowService</code> 类的对象的方法 <code>follow()</code> 实现点赞的功能。</li><li>新增方法 <code>unfollow()</code>：调用 HostHolder 对象的方法获取用户，调用业务层的 <code>FollowService</code> 类的对象的方法 <code>unfollow()</code> 实现取消点赞的功能。</li></ul><pre><code class="java">@Controllerpublic class FollowController &#123;    @Autowired    private FollowService followService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/follow&quot;)    @ResponseBody    public String follow(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        followService.follow(user.getId(), entityType, entityId);        return CommunityUtil.getJSONString(0, &quot; 已关注!&quot;);    &#125;    @PostMapping(&quot;/unfollow&quot;)    @ResponseBody    public String unfollow(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        followService.unfollow(user.getId(), entityType, entityId);        return CommunityUtil.getJSONString(0, &quot; 已取消关注!&quot;);    &#125;&#125;</code></pre><h1 id="4- 个人主页"><a href="#4- 个人主页" class="headerlink" title="4. 个人主页"></a>4. 个人主页 </h1><h2 id="更新业务层的 -FollowService- 类"><a href="# 更新业务层的 -FollowService- 类" class="headerlink" title="更新业务层的 FollowService 类"></a> 更新业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>findFolloweeCount()</code>，调用 zset 集合的方法 <code>zcard()</code> 查询某用户关注的实体数量。</p></li><li><p>新增方法 <code>findFollowerCount()</code>，调用 zset 集合的方法 <code>zcard()</code> 查询某实体的粉丝数量。</p></li><li><p>新增方法 <code>hasFollowed()</code>，根据 zset 集合的方法 <code>zscore()</code> 的返回值查询当前用户是否关注了某实体。</p></li></ul><pre><code class="java">// 查询关注的实体的数量public long findFolloweeCount(int userId, int entityType) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().zCard(followeeKey);&#125;// 查询实体的粉丝的数量public long findFollowerCount(int entityType, int entityId) &#123;    String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);    return redisTemplate.opsForZSet().zCard(followerKey);&#125;// 查询当前用户是否已关注该实体public boolean hasFollowed(int userId, int entityType, int entityId) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().score(followeeKey, entityId) != null;&#125;</code></pre><h2 id="更新表现层的 -UserController- 类 -1"><a href="# 更新表现层的 -UserController- 类 -1" class="headerlink" title="更新表现层的 UserController 类"></a>更新表现层的 UserController 类</h2><ul><li><p>调用业务层的 <code>LikeService</code> 类中的方法 <code>findUserLikeCount()</code> 查询用户获赞数，并添加到 Model 中。</p></li><li><p>调用业务层的 <code>FollowService</code> 类中的方法 <code>findFolloweeCount()</code> 查询关注数量，调用方法 <code>findFollowerCount()</code> 查询粉丝数量，调用方法 <code>hasFollowed()</code> 查询用户是否关注，并将三项信息存储于 Model 对象中。</p></li><li><p>更新获取个人主页方法 <code>getProfilePage()</code>：新增关注数、粉丝数、判断是否已关注，并将三项信息存储于 Model 对象中。</p></li></ul><pre><code class="java">// 个人主页@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)public String getProfilePage(@PathVariable(&quot;userId&quot;) int userId, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    // 用户    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    int likeCount = likeService.findUserLikeCount(userId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    // 关注数量    long followeeCount = followService.findFolloweeCount(userId, ENTITY_TYPE_USER);    model.addAttribute(&quot;followeeCount&quot;, followeeCount);    // 粉丝数量    long followerCount = followService.findFollowerCount(ENTITY_TYPE_USER, userId);    model.addAttribute(&quot;followerCount&quot;, followerCount);    // 是否已关注    boolean hasFollowed = false;    if (hostHolder.getUser() != null) &#123;        hasFollowed = followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);    &#125;    model.addAttribute(&quot;hasFollowed&quot;, hasFollowed);    return &quot;/site/profile&quot;;&#125;</code></pre><h1 id="5- 关注列表和粉丝列表"><a href="#5- 关注列表和粉丝列表" class="headerlink" title="5. 关注列表和粉丝列表"></a>5. 关注列表和粉丝列表 </h1><h2 id="更新业务层的 -FollowService- 类 -1"><a href="# 更新业务层的 -FollowService- 类 -1" class="headerlink" title="更新业务层的 FollowService 类"></a> 更新业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>findFollowees()</code>：查询用户关注列表。通过 zset 集合的方法 <code>reverseRange()</code> 获取 value 即关注用户的 userId，再查询出其对应的 user，之后通过 score 获取关注时间，存入 map 集合中，将 map 添加到 list 列表中并返回。</p></li><li><p>新增方法 <code>findFollowers()</code>：查询用户粉丝列表。通过 zset 集合的方法 <code>reverseRange()</code> 获取 value 即粉丝的 userId，再查询出其对应的 user，之后通过 score 获取关注时间，存入 map 集合中，将 map 添加到 list 列表中并返回。</p></li><li><p>新增方法 <code>hasFollowed()</code>，根据 zset 集合的方法 <code>zscore()</code> 的返回值查询当前用户是否关注了某实体。</p></li></ul><pre><code class="java">// 查询某用户关注的人public List&lt;Map&lt;String, Object&gt;&gt; findFollowees(int userId, int offset, int limit) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - 1);    if (targetIds == null) &#123;        return null;    &#125;    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (Integer targetId : targetIds) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        User user = userService.findUserById(targetId);        map.put(&quot;user&quot;, user);        Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);        map.put(&quot;followTime&quot;, new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;// 查询某用户的粉丝public List&lt;Map&lt;String, Object&gt;&gt; findFollowers(int userId, int offset, int limit) &#123;    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - 1);    if (targetIds == null) &#123;        return null;    &#125;    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (Integer targetId : targetIds) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        User user = userService.findUserById(targetId);        map.put(&quot;user&quot;, user);        Double score = redisTemplate.opsForZSet().score(followerKey, targetId);        map.put(&quot;followTime&quot;, new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;</code></pre><h2 id="更新表现层的 -FollowController- 类"><a href="# 更新表现层的 -FollowController- 类" class="headerlink" title="更新表现层的 FollowController 类"></a>更新表现层的 FollowController 类</h2><ul><li>新增方法 <code>getFollowees()</code>，获取关注列表，存入 Model 对象中。</li><li>新增方法 <code>getFollowers()</code>，获取粉丝列表，存入 Model 对象中。</li></ul><pre><code class="java">@GetMapping(&quot;/followees/&#123;userId&#125;&quot;)public String getFollowees(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    model.addAttribute(&quot;user&quot;, user);    page.setLimit(5);    page.setPath(&quot;/followees/&quot; + userId);    page.setRows((int) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowees(userId, page.getOffset(), page.getLimit());    if (userList != null) &#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            User u = (User) map.get(&quot;user&quot;);            map.put(&quot;hasFollowed&quot;, hasFollowed(u.getId()));        &#125;    &#125;    model.addAttribute(&quot;users&quot;, userList);    return &quot;/site/followee&quot;;&#125;@GetMapping(&quot;/followers/&#123;userId&#125;&quot;)public String getFollowers(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    model.addAttribute(&quot;user&quot;, user);    page.setLimit(5);    page.setPath(&quot;/followers/&quot; + userId);    page.setRows((int) followService.findFollowerCount(ENTITY_TYPE_USER, userId));    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowers(userId, page.getOffset(), page.getLimit());    if (userList != null) &#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            User u = (User) map.get(&quot;user&quot;);            map.put(&quot;hasFollowed&quot;, hasFollowed(u.getId()));        &#125;    &#125;    model.addAttribute(&quot;users&quot;, userList);    return &quot;/site/follower&quot;;&#125;private boolean hasFollowed(int userId) &#123;    if (hostHolder.getUser() == null) &#123;        return false;    &#125;    return followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);&#125;</code></pre><h1 id="6- 优化登录模块"><a href="#6- 优化登录模块" class="headerlink" title="6. 优化登录模块"></a>6. 优化登录模块</h1><ol><li><p>使用 Redis 存储验证码：验证码需要频繁访问与刷新，对性能要求较高；验证码不需要永久保存，通常在很短的时间内就会失效；分布式部署时，存在 Session 共享的问题。</p></li><li><p>使用 Redis 存储登录凭证：处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。</p></li><li><p>使用 Redis 缓存用户信息：每次处理请求时，都要根据凭证查询用户信息，访问的频率非常高。</p></li></ol><h2 id="6-1- 存储验证码"><a href="#6-1- 存储验证码" class="headerlink" title="6.1 存储验证码"></a>6.1 存储验证码</h2><ul><li>更新工具类 RedisUtil<ul><li>新增验证码前缀常量 <code>kaptcha</code></li><li>新增方法 <code>getKaptchaKey()</code>，通过用户凭证（由于未登录，采用 cookie 实现）获得对应验证码的 key（利用 String 存储验证码）。</li></ul></li></ul><pre><code class="java">private static final String PREFIX_KAPTCHA = &quot;kaptcha&quot;;// 登录验证码public static String getKaptchaKey(String owner) &#123;    return PREFIX_KAPTCHA + SPLIT + owner;&#125;</code></pre><ul><li>更新表现层的 LoginController 类<ul><li>重构方法 <code>getKaptcha()</code>，将验证码存入 redis，key 为当前随机生成的字符串，同时将该字符串存入 cookie。</li><li>重构方法 <code>login()</code>，从 cookie 中获取随机字符串，生成验证码的 key，然后获取 key 对应的 value 即验证码。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/kaptcha&quot;)public void getKaptcha(HttpServletResponse response/*, HttpSession session*/) &#123;    // 生成验证码    String text = kaptchaProducer.createText();    BufferedImage image = kaptchaProducer.createImage(text);    // 原来的做法：将验证码存入 session    // session.setAttribute(&quot;kaptcha&quot;, text);    // 验证码的归属    String kaptchaOwner = CommunityUtil.generateUUID();    Cookie cookie = new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);    cookie.setMaxAge(60);    cookie.setPath(contextPath);    response.addCookie(cookie);    // 将验证码存入 Redis    String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);    redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);    // 将图片输出给浏览器    response.setContentType(&quot;image/png&quot;);    try &#123;        OutputStream os = response.getOutputStream();        ImageIO.write(image, &quot;png&quot;, os);    &#125; catch (IOException e) &#123;        logger.error(&quot; 响应验证码失败:&quot; + e.getMessage());    &#125;&#125;@PostMapping(&quot;/login&quot;)public String login(String username, String password, String code, boolean rememberme,                    Model model, /*HttpSession session, */HttpServletResponse response,                    @CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner) &#123;    // 检查验证码    // String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);    String kaptcha = null;    if (StringUtils.isNotBlank(kaptchaOwner)) &#123;        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);        kaptcha = (String) redisTemplate.opsForValue().get(redisKey);    &#125;    if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123;        model.addAttribute(&quot;codeMsg&quot;, &quot; 验证码不正确!&quot;);        return &quot;/site/login&quot;;    &#125;    // 检查账号, 密码    int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);    if (map.containsKey(&quot;ticket&quot;)) &#123;        Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());        cookie.setPath(contextPath);        cookie.setMaxAge(expiredSeconds);        response.addCookie(cookie);        return &quot;redirect:/index&quot;;    &#125; else &#123;        model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;));        model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;));        return &quot;/site/login&quot;;    &#125;&#125;</code></pre><h2 id="6-2- 存储登录凭证"><a href="#6-2- 存储登录凭证" class="headerlink" title="6.2 存储登录凭证"></a>6.2 存储登录凭证</h2><ul><li>更新工具类 RedisUtil<ul><li>新增登录凭证前缀常量 <code>ticket</code></li><li>新增方法 <code>getTicketKey</code>() ，通过字符串获得登录凭证的对应 key （利用 String 存储）。</li></ul></li></ul><pre><code class="java">private static final String PREFIX_TICKET = &quot;ticket&quot;;// 登录的凭证public static String getTicketKey(String ticket) &#123;    return PREFIX_TICKET + SPLIT + ticket;&#125;</code></pre><ul><li><p>更新业务层的 UserService 类</p><ul><li><p>重构方法 <code>login()</code> ，将登录凭证存入 redis 中。</p></li><li><p>重构方法 <code>logout</code>() ，先从 redis 中获取登录凭证对象，将状态设为无效再重新存储进 redis。</p></li><li><p>重构方法 <code>findLoginTicket</code>() ，根据 ticket 字符串获得对应登录凭证的 key，然后从 redis 查询登录凭证。</p></li></ul></li></ul><pre><code class="java">public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) &#123;    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    // 空值处理    if (StringUtils.isBlank(username)) &#123;        map.put(&quot;usernameMsg&quot;, &quot; 账号不能为空!&quot;);        return map;    &#125;    if (StringUtils.isBlank(password)) &#123;        map.put(&quot;passwordMsg&quot;, &quot; 密码不能为空!&quot;);        return map;    &#125;    // 验证账号    User user = userMapper.selectByName(username);    if (user == null) &#123;        map.put(&quot;usernameMsg&quot;, &quot; 该账号不存在!&quot;);        return map;    &#125;    // 验证状态    if (user.getStatus() == 0) &#123;        map.put(&quot;usernameMsg&quot;, &quot; 该账号未激活!&quot;);        return map;    &#125;    // 验证密码    password = CommunityUtil.md5(password + user.getSalt());    if (!user.getPassword().equals(password)) &#123;        map.put(&quot;passwordMsg&quot;, &quot; 密码不正确!&quot;);        return map;    &#125;    // 生成登录凭证    LoginTicket loginTicket = new LoginTicket();    loginTicket.setUserId(user.getId());    loginTicket.setTicket(CommunityUtil.generateUUID());    loginTicket.setStatus(0);    loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));        // loginTicketMapper.insertLoginTicket(loginTicket);    String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());    redisTemplate.opsForValue().set(redisKey, loginTicket);    map.put(&quot;ticket&quot;, loginTicket.getTicket());    return map;&#125;public void logout(String ticket) &#123;        // loginTicketMapper.updateStatus(ticket, 1);    String redisKey = RedisKeyUtil.getTicketKey(ticket);    LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);    loginTicket.setStatus(1);    redisTemplate.opsForValue().set(redisKey, loginTicket);&#125;public LoginTicket findLoginTicket(String ticket) &#123;        // return loginTicketMapper.selectByTicket(ticket);    String redisKey = RedisKeyUtil.getTicketKey(ticket);    return (LoginTicket) redisTemplate.opsForValue().get(redisKey);&#125;public int updateHeader(int userId, String headerUrl) &#123;        // return userMapper.updateHeader(userId, headerUrl);    int rows = userMapper.updateHeader(userId, headerUrl);    clearCache(userId);    return rows;&#125;</code></pre><h2 id="6-3- 缓存用户信息"><a href="#6-3- 缓存用户信息" class="headerlink" title="6.3 缓存用户信息"></a>6.3 缓存用户信息</h2><ul><li><p>更新工具类 RedisUtil </p><ul><li><p>新增用户前缀常量 <code>user</code></p></li><li><p>新增 <code>getUserKey</code> 方法，通过用户 id 获得用户的对应 key 值（利用 String 存储）。</p></li></ul></li></ul><pre><code class="java">private static final String PREFIX_USER = &quot;user&quot;;// 用户public static String getUserKey(int userId) &#123;    return PREFIX_USER + SPLIT + userId;&#125;</code></pre><ul><li><p>更新业务层的 UserService 类</p><ul><li><p>新增 <code>getCache</code>()，从缓存获取用户信息。</p></li><li><p>新增 <code>initCache()</code>，从 MySQL 查询用户信息并存入 redis。</p></li><li><p>新增 <code>clearCache()</code>，用户信息变更（更新头像，激活）时清除缓存。</p></li><li><p>重构 <code>findUserById()</code> 方法，首先调用 <code>getCache()</code>从缓存获取用户信息，如果获取为 null 则调用 <code>initCache()</code>。</p></li></ul></li></ul><pre><code class="java">// 1. 优先从缓存中取值private User getCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    return (User) redisTemplate.opsForValue().get(redisKey);&#125;// 2. 取不到时初始化缓存数据private User initCache(int userId) &#123;    User user = userMapper.selectById(userId);    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);    return user;&#125;// 3. 数据变更时清除缓存数据private void clearCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.delete(redisKey);&#125;public User findUserById(int id) &#123;        // return userMapper.selectById(id);    User user = getCache(id);    if (user == null) &#123;        user = initCache(id);    &#125;    return user;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式流媒体平台 Kafka</title>
      <link href="/2023/03/07/Kafka/"/>
      <url>/2023/03/07/Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka- 简介"><a href="#Kafka- 简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介 </h1><p>🌟 <a href="http://kafka.apach.org/">Kafka 官网 </a></p><ul><li>Kafka 是一个分布式的流媒体平台。</li><li> 应用场景：消息系统、日志收集、用户行为追踪、流式处理。</li></ul><h1 id="Kafka- 特点"><a href="#Kafka- 特点" class="headerlink" title="Kafka 特点"></a>Kafka 特点 </h1><ul><li> 高吞吐量 </li><li> 消息持久化 </li><li> 高可靠性 </li><li> 高扩展性 </li></ul><h1 id="Kafka- 术语"><a href="#Kafka- 术语" class="headerlink" title="Kafka 术语"></a>Kafka 术语 </h1><ul><li>Broker</li><li>Zookeeper</li><li>Topic</li><li>Partition</li><li>Offset</li><li>Leader Replica</li><li>Follower Replica</li></ul><h1 id="Kafka- 配置"><a href="#Kafka- 配置" class="headerlink" title="Kafka 配置"></a>Kafka 配置 </h1><ol><li> 在 Kafka 安装包下的 config 文件夹下的 <code>zookeeper.properties</code> 文件内修改：</li></ol><pre><code class="properties"># 默认存放路径dataDir=/tmp/zookeeper</code></pre><ol start="2"><li> 在 Kafka 安装包下的 config 文件夹下的 <code>server.properties</code> 文件内修改：</li></ol><pre><code class="properties"># 默认存放路径log.dirs=/tmp/kafka-logs</code></pre><h1 id="Kafka- 常用命令"><a href="#Kafka- 常用命令" class="headerlink" title="Kafka 常用命令"></a>Kafka 常用命令 </h1><ol><li> 打开一个 terminal 窗口，启动 Zookeeper：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ zookeeper-server-start.sh config\zookeeper.properties</code></pre><ol start="2"><li> 打开另一个 terminal 窗口，启动 Kafka：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ zookeeper-server-start.sh config\server.properties</code></pre><ol start="3"><li> 打开另一个 terminal 窗口，发布 topic 为 test，创建 1 个副本，创建 1 个分区：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test</code></pre><ol start="4"><li> 查看是否成功发布 topic：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-topics.sh --list --bootstrap-server localhost:9092</code></pre><pre><code class="sh"># 发布 topic 成功，terminal 显示 testtest</code></pre><ol start="5"><li> 生产者发布消息：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-console-producer.sh --broker-list localhost:9092 --topic test</code></pre><ol start="6"><li> 消费者订阅消息：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre><h1 id="Windows- 下关于 -Kafka- 的使用注意点"><a href="#Windows- 下关于 -Kafka- 的使用注意点" class="headerlink" title="Windows 下关于 Kafka 的使用注意点"></a>Windows 下关于 Kafka 的使用注意点 </h1><ul><li> 问题：在 Windows 的命令行里启动 Kafka 之后，当关闭命令行窗口时，就会强制关闭 Kafka。这种关闭方式为暴力关闭，很可能会导致 Kafka 无法完成对日志文件的解锁。届时，再次启动 Kafka 的时候，就会提示日志文件被锁，无法成功启动。</li><li> 方案：将 Kafka 的日志文件全部删除，再次启动即可。</li><li> 建议：不要暴力关闭 Kafka，建议通过在命令行执行 <code>kafka-server-stop</code> 命令来关闭它。</li><li> 其他：将来在 Linux 上部署 Kafka 之后，采用后台运行的方式，就会避免这样的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 下安装 Node.js 避坑指南</title>
      <link href="/2023/03/05/macos_nodejs/"/>
      <url>/2023/03/05/macos_nodejs/</url>
      
        <content type="html"><![CDATA[<ul><li><p>不建议的方法：直接到 Node 官网下载 <code>.pkg</code> 文件进行安装。</p></li><li><p>可能出现的问题：使用 <code>npm install -g hexo-cli</code> 等指令会报错没有写入的权限，甚至尝试各种 <code>sudo</code> 权限都无效。</p></li><li><p>npm 官网教程也不推荐采用 <code>installer</code> 进行安装。</p></li></ul><h2 id="安装 Node-js 和 npm 的正确方法"><a href="# 安装 Node-js 和 npm 的正确方法" class="headerlink" title="安装 Node.js 和 npm 的正确方法"></a>安装 Node.js 和 npm 的正确方法 </h2><p>🌟 使用 node 版本管理工<code>nvm</code>(node version manager) 安装 Node.js 和 npm。</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>安装<code>nvm</code>：</p><pre><code>~$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</code></pre><p>验证 <code>nvm</code> 是否安装成功：</p><pre><code>~$ command -v nvm</code></pre><p>若成功则出现一行 <code>nvm</code> 字符 (若未出现则重启<code>terminal</code>)，查询<code>nvm</code> 版本：</p><pre><code>~$ nvm --version</code></pre><p>返回 <code>nvm</code> 版本号：<code>0.34.0</code></p><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>使用 <code>nvm</code> 安装<code>node</code>：</p><pre><code>~$ nvm install node # &quot;node&quot; is an alias for the latest version</code></pre><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>使用 <code>npm</code> 指令安装<code>hexo</code>：</p><pre><code>~$ npm install -g hexo-cli</code></pre><p>初始化<code>hexo</code>，指定文件夹名为 blog：</p><pre><code>~$ hexo init blog</code></pre><p>进入 blog 文件夹下，安装<code>npm</code>：</p><pre><code>~ $ cd blog~ $ npm istall</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>Q1：<code>zsh: command not found: nvm</code></p><p>A1：进入 .nvm 文件夹，查看是否存在 .bash_profile 文件，若存在该文件则直接打开：</p><pre><code>cd ~/.nvmopen .bash_profile</code></pre><p>若不存在则先创建 .bash_profile 文件：</p><pre><code>touch .bash_profile</code></pre><p>然后在 .bash_profile 文件内写入：</p><pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;[-s &quot;$NVM_DIR/nvm.sh&quot;] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</code></pre><p>写入完毕后，关闭文件，执行 .bash_profile 文件：</p><pre><code>source .bash_profile</code></pre><p>Q2：每次关闭 <code>terminal</code> 后，又出现 <code>zsh: command not found: nvm</code> 等无法找到某指令的情况，需要重新执行 .bash_profile 文件。</p><p>A2：原因是采用的 <code>terminal</code> 是<code>zsh</code>，需要将配置添加到 .zshrc 文件中。</p><p>打开  .zshrc 文件：</p><pre><code>open ~/.zshrc</code></pre><p>在 .zshrc 文件内写入：</p><pre><code>export NVM_DIR=~/.nvm[-s &quot;$NVM_DIR/nvm.sh&quot;] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;</code></pre><p>写入完毕后，关闭文件，执行 .zshrc 文件：</p><pre><code>source ~/.zshrc</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式搜索引擎 Elasticsearch</title>
      <link href="/2023/03/02/Elasticsearch/"/>
      <url>/2023/03/02/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch 简介"><a href="#Elasticsearch 简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介 </h1><ul><li> 一个分布式的、Restful 风格的搜索引擎。 </li><li> 支持对各种类型的数据的检索。 </li><li> 搜索速度快，可以提供实时的搜索服务。 </li><li> 便于水平扩展，每秒可以处理 PB 级海量数据。 </li><li>Elasticsearch 术语 <ul><li> 索引、类型、文档、字段 </li><li> 集群、节点、分片、副本。</li></ul></li></ul><h1 id="Elasticsearch- 配置"><a href="#Elasticsearch- 配置" class="headerlink" title="Elasticsearch 配置"></a>Elasticsearch 配置 </h1><ol><li> 在 Elasticsearch 安装包下的 config 文件夹下的 <code>slasticsearch.yml</code> 文件内修改：</li></ol><pre><code class="yaml"># 集群名cluster.name = my-application# 数据存储路径path.data: /path/to/data# 日志存放路径path.logs: /path/to/logs</code></pre><ol start="2"><li>ES 默认申请 1G 内存，可在 Elasticsearch 安装包下的 config 文件夹下的 <code>jvm.options</code> 文件内修改：</li></ol><pre><code class="properties"># 初始内存-Xms256m# 最大内存-Xmx512m</code></pre><ol start="3"><li> 安装分词插件 <a href="https://github.com/medcl/elasticsearch-analysis-ik">elasticsearch-analysis-ik</a>，将其放到 Elasticsearch 安装包下的 plugins 文件夹下的 ik 文件夹下。在 IKAnalyzer.cfg.xml 文件内可以配置自定义词，在同级目录下新建 <code>.dic</code> 文件即可。</li></ol><table><thead><tr><th align="center">IK version</th><th align="center">ES version</th></tr></thead><tbody><tr><td align="center">master</td><td align="center">7.x -&gt; master</td></tr><tr><td align="center">6.x</td><td align="center">6.x</td></tr><tr><td align="center">5.x</td><td align="center">5.x</td></tr><tr><td align="center">1.10.6</td><td align="center">2.4.6</td></tr><tr><td align="center">1.9.5</td><td align="center">2.3.5</td></tr><tr><td align="center">1.8.1</td><td align="center">2.2.1</td></tr><tr><td align="center">1.7.0</td><td align="center">2.1.1</td></tr><tr><td align="center">1.5.0</td><td align="center">2.0.0</td></tr><tr><td align="center">1.2.6</td><td align="center">1.0.0</td></tr><tr><td align="center">1.2.5</td><td align="center">0.90.x</td></tr><tr><td align="center">1.1.3</td><td align="center">0.20.x</td></tr><tr><td align="center">1.0.0</td><td align="center">0.16.2 -&gt; 0.19.0</td></tr></tbody></table><ol start="4"><li> 安装 <a href="https://www.postman.com/">Postman</a>，可通过其访问 Elasticsearch 服务器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之数据库表</title>
      <link href="/2023/03/01/table/"/>
      <url>/2023/03/01/table/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录校园社区论坛项目的数据库表，包含五张表：用户表 user、评论表 comment、帖子表 discuss_post、用户登录凭证表 login_ticket、消息表 message。</p><p>🌟 将数据库字段 (下划线形式) 与实体类 (驼峰命名法) 建立映射。</p><h1 id="1- 用户表 -user"><a href="#1- 用户表 -user" class="headerlink" title="1. 用户表 user"></a>1. 用户表 user</h1><ul><li> 用户表 user</li></ul><table><thead><tr><th align="center"> 字段 </th><th align="center"> 类型 </th><th align="center"> 备注 </th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"> 主键、自增 </td></tr><tr><td align="center">username</td><td align="center">varchar</td><td align="center"> 用户名，创建索引 </td></tr><tr><td align="center">password</td><td align="center">varchar</td><td align="center"> 用户密码 </td></tr><tr><td align="center">salt</td><td align="center">varchar</td><td align="center"> 加密盐值 </td></tr><tr><td align="center">email</td><td align="center">varchar</td><td align="center"> 用户邮箱，创建索引 </td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center"> 用户类型：0 - 普通用户、1 - 管理员、2 - 版主 </td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center"> 用户状态：0 - 未激活、1 - 已激活 </td></tr><tr><td align="center">activation_code</td><td align="center">varchar</td><td align="center"> 激活码 </td></tr><tr><td align="center">header_url</td><td align="center">varchar</td><td align="center"> 用户头像地址 </td></tr><tr><td align="center">create_time</td><td align="center">timestamp</td><td align="center"> 注册时间 </td></tr></tbody></table><ul><li> 实体类 User</li></ul><pre><code class="java">public class User &#123;    private int id;    private String username;    private String password;    private String salt;    private String email;    private int type;    private int status;    private String activationCode;    private String headerUrl;    private Date createTime;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getSalt() &#123;        return salt;    &#125;    public void setSalt(String salt) &#123;        this.salt = salt;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public int getType() &#123;        return type;    &#125;    public void setType(int type) &#123;        this.type = type;    &#125;    public int getStatus() &#123;        return status;    &#125;    public void setStatus(int status) &#123;        this.status = status;    &#125;    public String getActivationCode() &#123;        return activationCode;    &#125;    public void setActivationCode(String activationCode) &#123;        this.activationCode = activationCode;    &#125;    public String getHeaderUrl() &#123;        return headerUrl;    &#125;    public void setHeaderUrl(String headerUrl) &#123;        this.headerUrl = headerUrl;    &#125;    public Date getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Date createTime) &#123;        this.createTime = createTime;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                &quot;, salt=&#39;&quot; + salt + &#39;\&#39;&#39; +                &quot;, email=&#39;&quot; + email + &#39;\&#39;&#39; +                &quot;, type=&quot; + type +                &quot;, status=&quot; + status +                &quot;, activationCode=&#39;&quot; + activationCode + &#39;\&#39;&#39; +                &quot;, headerUrl=&#39;&quot; + headerUrl + &#39;\&#39;&#39; +                &quot;, createTime=&quot; + createTime +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h1 id="2- 评论表 -comment"><a href="#2- 评论表 -comment" class="headerlink" title="2. 评论表 comment"></a>2. 评论表 comment</h1><ul><li> 评论表 comment</li></ul><table><thead><tr><th align="center"> 字段 </th><th align="center"> 类型 </th><th align="center"> 备注 </th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"> 主键、自增 </td></tr><tr><td align="center">user_id</td><td align="center">int</td><td align="center"> 评论的用户 id，创建索引 </td></tr><tr><td align="center">entity_id</td><td align="center">int</td><td align="center"> 评论实体 id，创建索引 </td></tr><tr><td align="center">entity_type</td><td align="center">int</td><td align="center"> 评论实体类型：1 - 帖子评论、2 - 评论回复 </td></tr><tr><td align="center">target_id</td><td align="center">int</td><td align="center"> 评论目标 id</td></tr><tr><td align="center">content</td><td align="center">text</td><td align="center"> 评论内容 </td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center"> 评论状态：0 - 有效、1 - 无效 </td></tr><tr><td align="center">create_time</td><td align="center">timestamp</td><td align="center"> 评论发表时间 </td></tr></tbody></table><ul><li> 实体类 Comment</li></ul><pre><code class="java">public class Comment &#123;    private int id;    private int userId;    private int entityType;    private int entityId;    private int targetId;    private String content;    private int status;    private Date createTime;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public void setUserId(int userId) &#123;        this.userId = userId;    &#125;    public int getEntityType() &#123;        return entityType;    &#125;    public void setEntityType(int entityType) &#123;        this.entityType = entityType;    &#125;    public int getEntityId() &#123;        return entityId;    &#125;    public void setEntityId(int entityId) &#123;        this.entityId = entityId;    &#125;    public int getTargetId() &#123;        return targetId;    &#125;    public void setTargetId(int targetId) &#123;        this.targetId = targetId;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;    public int getStatus() &#123;        return status;    &#125;    public void setStatus(int status) &#123;        this.status = status;    &#125;    public Date getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Date createTime) &#123;        this.createTime = createTime;    &#125;    @Override    public String toString() &#123;        return &quot;Comment&#123;&quot; +                &quot;id=&quot; + id +                &quot;, userId=&quot; + userId +                &quot;, entityType=&quot; + entityType +                &quot;, entityId=&quot; + entityId +                &quot;, targetId=&quot; + targetId +                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +                &quot;, status=&quot; + status +                &quot;, createTime=&quot; + createTime +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h1 id="3- 帖子表 -discuss-post"><a href="#3- 帖子表 -discuss-post" class="headerlink" title="3. 帖子表 discuss_post"></a>3. 帖子表 discuss_post</h1><ul><li> 帖子表 discuss_post</li></ul><table><thead><tr><th align="center"> 字段 </th><th align="center"> 类型 </th><th align="center"> 备注 </th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"> 主键、自增 </td></tr><tr><td align="center">user_id</td><td align="center">int</td><td align="center"> 发帖的用户 id，创建索引 </td></tr><tr><td align="center">title</td><td align="center">varchar</td><td align="center"> 帖子表标题 </td></tr><tr><td align="center">content</td><td align="center">text</td><td align="center"> 帖子内容 </td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center"> 帖子类型：0 - 普通、1 - 置顶 </td></tr><tr><td align="center">comment_count</td><td align="center">int</td><td align="center"> 评论数量 </td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center"> 帖子状态：0 - 普通、1 - 精华、2 - 拉黑 </td></tr><tr><td align="center">create_time</td><td align="center">timestamp</td><td align="center"> 评论发表时间 </td></tr></tbody></table><ul><li> 实体类 DiscussPost</li></ul><pre><code class="java">public class DiscussPost &#123;    private int id;    private int userId;    private String title;    private String content;    private int type;    private int status;    private Date createTime;    private int commentCount;    private double score;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public void setUserId(int userId) &#123;        this.userId = userId;    &#125;    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;    public int getType() &#123;        return type;    &#125;    public void setType(int type) &#123;        this.type = type;    &#125;    public int getStatus() &#123;        return status;    &#125;    public void setStatus(int status) &#123;        this.status = status;    &#125;    public Date getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Date createTime) &#123;        this.createTime = createTime;    &#125;    public int getCommentCount() &#123;        return commentCount;    &#125;    public void setCommentCount(int commentCount) &#123;        this.commentCount = commentCount;    &#125;    public double getScore() &#123;        return score;    &#125;    public void setScore(double score) &#123;        this.score = score;    &#125;    @Override    public String toString() &#123;        return &quot;DiscussPost&#123;&quot; +                &quot;id=&quot; + id +                &quot;, userId=&quot; + userId +                &quot;, title=&#39;&quot; + title + &#39;\&#39;&#39; +                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +                &quot;, type=&quot; + type +                &quot;, status=&quot; + status +                &quot;, createTime=&quot; + createTime +                &quot;, commentCount=&quot; + commentCount +                &quot;, score=&quot; + score +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h1 id="4- 用户登录凭证表 -login-ticket"><a href="#4- 用户登录凭证表 -login-ticket" class="headerlink" title="4. 用户登录凭证表 login_ticket"></a>4. 用户登录凭证表 login_ticket</h1><ul><li> 用户登录凭证表 login_ticket</li></ul><table><thead><tr><th align="center"> 字段 </th><th align="center"> 类型 </th><th align="center"> 备注 </th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"> 主键、自增 </td></tr><tr><td align="center">user_id</td><td align="center">int</td><td align="center"> 登录用户 id</td></tr><tr><td align="center">ticket</td><td align="center">varchar</td><td align="center"> 登录凭证，随机字符串 </td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center"> 登录状态：0 - 有效、1 - 无效 </td></tr><tr><td align="center">expired</td><td align="center">timestamp</td><td align="center"> 过期时间 </td></tr></tbody></table><ul><li> 实体类 LoginTicket</li></ul><pre><code class="java">public class LoginTicket &#123;    private int id;    private int userId;    private String ticket;    private int status;    private Date expired;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public void setUserId(int userId) &#123;        this.userId = userId;    &#125;    public String getTicket() &#123;        return ticket;    &#125;    public void setTicket(String ticket) &#123;        this.ticket = ticket;    &#125;    public int getStatus() &#123;        return status;    &#125;    public void setStatus(int status) &#123;        this.status = status;    &#125;    public Date getExpired() &#123;        return expired;    &#125;    public void setExpired(Date expired) &#123;        this.expired = expired;    &#125;    @Override    public String toString() &#123;        return &quot;LoginTicket&#123;&quot; +                &quot;id=&quot; + id +                &quot;, userId=&quot; + userId +                &quot;, ticket=&#39;&quot; + ticket + &#39;\&#39;&#39; +                &quot;, status=&quot; + status +                &quot;, expired=&quot; + expired +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h1 id="5- 消息表 -message"><a href="#5- 消息表 -message" class="headerlink" title="5. 消息表 message"></a>5. 消息表 message</h1><ul><li> 消息表 message</li></ul><table><thead><tr><th align="center"> 类型 </th><th align="center"> 字段 </th><th align="center"> 备注 </th></tr></thead><tbody><tr><td align="center">int</td><td align="center">id</td><td align="center"> 主键、自增 </td></tr><tr><td align="center">int</td><td align="center">from_id</td><td align="center"> 发消息的 id，创建索引 </td></tr><tr><td align="center">int</td><td align="center">to_id</td><td align="center"> 收消息的 id，创建索引 </td></tr><tr><td align="center">varchar</td><td align="center">conversation_id</td><td align="center"> 会话 id，由通信双方 id 拼接，创建索引 </td></tr><tr><td align="center">text</td><td align="center">content</td><td align="center"> 消息内容 </td></tr><tr><td align="center">int</td><td align="center">status</td><td align="center"> 消息状态：0 - 未读、1 - 已读、2 - 删除 </td></tr><tr><td align="center">timestamp</td><td align="center">create_time</td><td align="center"> 消息发送时间 </td></tr></tbody></table><ul><li> 实体类 Message</li></ul><pre><code class="java">public class Message &#123;    private int id;    private int fromId;    private int toId;    private String conversationId;    private String content;    private int status;    private Date createTime;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getFromId() &#123;        return fromId;    &#125;    public void setFromId(int fromId) &#123;        this.fromId = fromId;    &#125;    public int getToId() &#123;        return toId;    &#125;    public void setToId(int toId) &#123;        this.toId = toId;    &#125;    public String getConversationId() &#123;        return conversationId;    &#125;    public void setConversationId(String conversationId) &#123;        this.conversationId = conversationId;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;    public int getStatus() &#123;        return status;    &#125;    public void setStatus(int status) &#123;        this.status = status;    &#125;    public Date getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Date createTime) &#123;        this.createTime = createTime;    &#125;    @Override    public String toString() &#123;        return &quot;Message&#123;&quot; +                &quot;id=&quot; + id +                &quot;, fromId=&quot; + fromId +                &quot;, toId=&quot; + toId +                &quot;, conversationId=&#39;&quot; + conversationId + &#39;\&#39;&#39; +                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +                &quot;, status=&quot; + status +                &quot;, createTime=&quot; + createTime +                &#39;&#125;&#39;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式 NoSQL 数据库 Redis</title>
      <link href="/2023/03/01/Redis/"/>
      <url>/2023/03/01/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Redis- 基础"><a href="#1-Redis- 基础" class="headerlink" title="1. Redis 基础"></a>1. Redis 基础</h1><h2 id="1-1- 简介"><a href="#1-1- 简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Redis 是一个基于 C 语言开发的开源数据库，区别于传统数据库，其数据存储于内存之中 (内存数据库)。</p><h2 id="1-2- 特点"><a href="#1-2- 特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ul><li><p>读写速度快 (缓存)</p></li><li><p>存储 key - value 键值对数据</p></li></ul><h2 id="1-3- 数据结构"><a href="#1-3- 数据结构" class="headerlink" title="1.3 数据结构"></a>1.3 数据结构</h2><ul><li>五种基础数据结构：<ul><li>String</li><li>List</li><li>Hash</li><li>Set</li><li>Zset</li></ul></li><li>三种特殊数据结构：<ul><li>HyperLogLog</li><li>Bitmap</li><li>Geospatial</li></ul></li></ul><h2 id="1-4- 应用场景"><a href="#1-4- 应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h2><ul><li>事务</li><li>持久化</li><li>Lua 脚本</li><li>开箱即用的集群方案 (Redis Sentinel、Redis Cluster) 等</li></ul><h2 id="1-5-Redis- 为什么快？"><a href="#1-5-Redis- 为什么快？" class="headerlink" title="1.5 Redis 为什么快？"></a>1.5 Redis 为什么快？</h2><ul><li>基于内存，内存的访问速度远超磁盘；</li><li>基于 Reactor 设计模式，采用单线程架构和 IO 多路复用；</li><li>内置了多种优化后的数据结构实现，性能高。</li></ul><h1 id="2-Redis- 与 -Memcached- 的异同点"><a href="#2-Redis- 与 -Memcached- 的异同点" class="headerlink" title="2. Redis 与 Memcached 的异同点"></a>2. Redis 与 Memcached 的异同点</h1><ul><li>共同点<ul><li>均基于内存，一般用作缓存；</li><li>均有过期策略；</li><li>均性能较高。</li></ul></li><li>不同点<ul><li>Redis 支持更丰富的数据类型即可用的场景更多；</li><li>Redis 支持数据持久化，将内存的数据保持在磁盘中，重启时可以再次加载使用，Memcached 则将所有数据存于内存之中；</li><li>Redis 有灾难恢复机制，可以将缓存中的数据持久化到磁盘上；</li><li>Redis 在服务器内存使用完后将不用的数据放到磁盘上，Memcached 在服务器内存使用完后会报异常；</li><li>Redis 原生支持 cluster 模式，Memcached 无原生的集群模式，依赖于客户端实现集群中分片写入数据；</li><li>Redis 采用单线程的多路 IO 复用模型，Mencached 则是多线程的；</li><li>Redis 支持发布 - 订阅模式、Lua 脚本、事务等功能，Memcached 则不支持；</li><li>Redis 同时使用惰性删除和定期删除，Memcached 过期数据的删除策略只用了惰性删除。</li></ul></li></ul><h1 id="3- 为什么要用 -Redis- 缓存 -？"><a href="#3- 为什么要用 -Redis- 缓存 -？" class="headerlink" title="3. 为什么要用 Redis ( 缓存)？"></a>3. 为什么要用 Redis (缓存)？</h1><ul><li><p>高性能</p><ul><li>将用户经常访问的、不经常变更的高频数据存入缓存，相较于每次从硬盘读取数据要快得多。</li></ul></li><li><p>高并发</p><ul><li>采用 Redis 缓存的 QPS 高于 MySQL，使用 Redis 集群则会更高。将数据库中的部分数据转移到缓存中去，可以使得用户的部分请求不需要经过数据库而是直接从缓存中读取，从而提高整体的并发行。</li></ul></li></ul><h1 id="4-Redis- 的用途"><a href="#4-Redis- 的用途" class="headerlink" title="4. Redis 的用途"></a>4. Redis 的用途 </h1><p> 除了用作缓存意外以外，Redis 还可以用作：</p><ul><li>分布式锁：一般基于 Redisson 实现；</li><li>限流：一般通过 Redis + Lua 脚本的方式实现；</li><li>消息队列：自带的 list 可用作消息队列，Redis 5.0 新增的 Stream 类型的数据结构更适合用作消息队列，且支持消息持久化和 ACK 机制；</li><li>复杂业务场景：通过 bitmap 统计活跃用户，通过 sorted set 维护排行榜。</li></ul><h1 id="5-Redis-5-0- 新增的 -Stream"><a href="#5-Redis-5-0- 新增的 -Stream" class="headerlink" title="5. Redis 5.0 新增的 Stream"></a>5. Redis 5.0 新增的 Stream</h1><p>新增的数据结构 Stream 支持：</p><ul><li>发布 - 订阅模式；</li><li>按照消费者组进行消费；</li><li>消息持久化 (RDB、AOF)。</li></ul><h1 id="6-Redis- 单线程模型"><a href="#6-Redis- 单线程模型" class="headerlink" title="6. Redis 单线程模型"></a>6. Redis 单线程模型</h1><p>Redis 基于 Reactor 设计模式开发了一套高效的事件处理模型，对应 Redis 中的文件事件处理器 (file event handler) ，该处理器是单线程的，因此一般说 Redis 是单线程模型。文件事件处理器以单线程方式运行，但是通过使用 I&#x2F;O 多路复用程序监听多个套接字，既实现了高性能的网络通信模型，又可以与 Redis 中的其他单线程模块对接，保持了 Redis 内部单线程设计的简单性。</p><ul><li>文件事件处理器 file event handler 的四个主要组成部分：<ul><li>多个 socket (客户端连接)</li><li>IO 多路复用程序 (支持多个客户端连接的关键)</li><li>文件事件分派器 (将 socket 关联到相应的事件处理器)</li><li>事件处理器 (连接应答处理器、命令请求处理器、命令回复处理器 、主从连接处理器)</li></ul></li></ul><h1 id="7- 过期数据的删除策略"><a href="#7- 过期数据的删除策略" class="headerlink" title="7. 过期数据的删除策略"></a>7. 过期数据的删除策略</h1><ul><li>惰性删除：仅在取出 key 的时候对数据进行过期检测，但可能造成过多的过期 key 未被删除。</li><li>定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ul><p>惰性删除对 CPU 友好，定期删除对内存友好，因此 Redis 采用定期删除 + 惰性删除 &#x2F; 懒汉式删除，同时结合内存淘汰机制。</p><h1 id="8-Redis- 持久化机制"><a href="#8-Redis- 持久化机制" class="headerlink" title="8. Redis 持久化机制"></a>8. Redis 持久化机制</h1><h2 id="8-1-RDB- 持久化"><a href="#8-1-RDB- 持久化" class="headerlink" title="8.1 RDB 持久化"></a>8.1 RDB 持久化</h2><p>RDB 持久化即快照持久化 (snapshooting)，Redis 通过创建快照来获得存储在内存中的数据在某个时间点上的副本。由于 Redis 具有主从结构，在其创建快照后，可以将快照备份至其他服务器即创建副本。</p><h2 id="8-2-AOF- 持久化"><a href="#8-2-AOF- 持久化" class="headerlink" title="8.2 AOF 持久化"></a>8.2 AOF 持久化</h2><p>AOF (append only file) 持久化，相比快照持久化具有更好的实时性。开启 AOF 持久化方式后，每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存中，然后根据配置来决定何时将其同步到硬盘中的 AOF 文件中。Redis AOF 持久化机制在执行完命令后再记录日志。</p><h1 id="9-Redis- 事务"><a href="#9-Redis- 事务" class="headerlink" title="9. Redis 事务"></a>9. Redis 事务 </h1><p>Redis 通过 <code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code> 等命令实现事务。</p><p>实现 Redis 事务流程：</p><ul><li>开始事务 (MULTI)；</li><li>命令入队：批量操作 Redis 命令，按照 FIFO 的顺序执行；</li><li>执行事务 (EXEC)。</li></ul><h1 id="10- 缓存穿透"><a href="#10- 缓存穿透" class="headerlink" title="10. 缓存穿透"></a>10. 缓存穿透 </h1><p> 当客户端向服务器发送大量读请求时，由于 Redis 缓存中没有对应的数据，大量读请求落到数据库上，但数据库也没有对应的数据，导致“缓存穿透”。</p><p>注：此处大量读请求的 key 是不合理的。 </p><p>🌟 解决方法：</p><ul><li>缓存无效 key</li><li>布隆过滤器</li></ul><h1 id="11- 缓存击穿"><a href="#11- 缓存击穿" class="headerlink" title="11. 缓存击穿"></a>11. 缓存击穿 </h1><p> 当客户端向服务器发送大量读请求时，由于 Redis 缓存中没有对应的数据 (可能已经过期了)，大量读请求落到数据库中 (虽然数据库中存在该数据但是 Redis 缓存中没有该数据)，导致“缓存击穿”。</p><p>注：此处大量读请求的 key 对应热点数据。</p><p>🌟 解决方法：</p><ul><li>设置热点数据永不过期 &#x2F; 过期时间较长；</li><li>针对热点数据提前预热，将其存入缓存并设置合理的过期时间；</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求落到数据库上，减轻数据库的压力。</li></ul><h1 id="12- 缓存雪崩"><a href="#12- 缓存雪崩" class="headerlink" title="12. 缓存雪崩"></a>12. 缓存雪崩 </h1><p> 当客户端向服务器发送大量读请求时，由于 Redis 缓存中对应的大量数据同时过期，大量读请求落到数据库上 (数据库中存在对应的数据)，导致“缓存雪崩”。</p><p>🌟 解决方法：</p><ol><li>针对 Redis 服务不可用情况：</li></ol><ul><li>采用 Redis 集群，避免单机出现问题导致整个缓存服务都没法使用；</li><li>限流，避免同时处理大量的请求。</li></ul><ol start="2"><li>针对热点缓存失效情况：</li></ol><ul><li>设置不同的失效事件，例如随机设置缓存的失效时间；</li><li>缓存永不失效，不推荐；</li><li>设置二级缓存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 算法笔记之链表 (双指针解法)</title>
      <link href="/2023/03/01/linkedlist/"/>
      <url>/2023/03/01/linkedlist/</url>
      
        <content type="html"><![CDATA[<p>🌟 LeetCode 算法笔记之链表，复习整理双指针解决链表题目。</p><h1 id="141- 环形链表"><a href="#141- 环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表 </h1><p><a href="https://leetcode.cn/problems/linked-list-cycle/"> 题源：141. Linked List Cycle</a></p><blockquote><p>给你一个链表的头结点 head ，判断链表中是否有环。</p><p>如果链表中有某个结点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置双指针，慢指针 slow 每次前进一步，快指针 fast 每次前进两步。</li><li>如果 fast 最终遇到空指针，说明链表中没有环。</li><li>如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        ListNode fast = head, slow = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;            if (fast == slow) return true;        &#125;        return false;    &#125;&#125;</code></pre><h1 id="142- 环形链表 -II"><a href="#142- 环形链表 -II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">题源：142. Linked List Cycle II</a></p><blockquote><p>给定一个链表的头结点  head ，返回链表开始入环的第一个结点。 如果链表无环，则返回 null。</p><p>如果链表中有某个结点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p></blockquote><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ol><li>原理：</li></ol><ul><li><p>当快、慢指针分别以 2v、v 的速度前进并第一次相遇时：</p><ul><li><p>如果慢指针走了 k 步，则快指针一定走了 2k 步。</p></li><li><p>快指针比慢指针多走的 k 步，其实就是快指针在环内转圈，即 k 值为环长度的 <em>整数倍</em>。</p></li><li><p>假设相遇点 M 距离环的起点 C 的距离为 m，则慢指针从头结点 H 到环的起点 C 的移动距离 HC 为 <code>k - m</code>。</p></li><li><p>也就是说如果快、慢指针在相遇点 M 时，重置慢指针，让慢指针再次从头结点 H 出发，前进 <code>k - m</code> 步即可到达环的起点 C。</p></li><li><p>此时，如果快指针从相遇点继续前进，且速度和慢指针保持一致都为 v，恰巧也需前进 <code>k - m</code> 步即可到达环的起点 C。</p></li></ul></li></ul><ol start="2"><li>解法：</li></ol><ul><li>设置双指针，慢指针 slow 每次前进一步，快指针 fast 每次前进两步。</li><li>当快、慢指针相遇时：<ul><li>让其中一个指针指向头结点；</li><li>此时，设置快、慢指针前进速度一致，均每次前进一步。</li></ul></li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><ul><li>第一个 while 循环是为了寻找相遇点 M。</li><li>第二个 while 循环是为了重置慢指针到头结点，并寻找两个指针最终的位置即环起点。</li></ul><pre><code class="java">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        ListNode fast = head, slow = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;            if (slow == fast) break;        &#125;        if (fast == null || fast.next == null) return null;        slow = head;        while (slow != fast) &#123;            fast = fast.next;            slow = slow.next;        &#125;        return slow;    &#125;&#125;</code></pre><h1 id="160- 相交链表"><a href="#160- 相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表 </h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/"> 题源：160. 相交链表</a></p><blockquote><p>给你两个单链表的头结点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始结点。如果两个链表不存在相交结点，返回 <code>null</code> 。</p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意 </strong>，函数返回结果后，链表必须 <strong> 保持其原始结构</strong> 。</p></blockquote><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置两个指针 p1 和 p2，分别指向 链表 A 和链表 B 的头结点。</li><li>让指针 p1 和 p2 分别在在两条链表上遍历：<ul><li>当指针 p1 遍历完链表 A 后，开始遍历链表 B；</li><li>当指针 p2 遍历完链表 B 后，开始遍历链表 A；</li><li>在逻辑上，两条链表“连接成了一条链表”。</li></ul></li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        ListNode p1 = headA, p2 = headB;        while (p1 != p2) &#123;            if (p1 != null) &#123;                p1 = p1.next;            &#125; else &#123;                p1 = headB;            &#125;            if (p2 != null) &#123;                p2 = p2.next;            &#125; else &#123;                p2 =headA;            &#125;        &#125;        return p1;    &#125;&#125;</code></pre><h1 id="19- 删除链表的倒数第 -N- 个结点"><a href="#19- 删除链表的倒数第 -N- 个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点 </h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/"> 题源：19. 删除链表的倒数第 N 个结点</a></p><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p></blockquote><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><ul><li>要删除链表的倒数第 n 个结点，则需要获得倒数第 n + 1 个结点的引用。</li><li>设置指针 p1 和 p2，首先让指针 p1 指向链表的头结点，并向前移动 k 步；</li><li>此时，让指针 p2 指向链表的头结点，并让两个指针 p1 和 p2 同时向前移动；</li><li>当指针 p1 移动至链表末尾的空指针时，其移动的第二段长度为 <code>n - k</code> 步，而此时指针 p2 也移动了 <code>n - k</code>步，位于链表的倒数第 k 个结点。</li></ul><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><ul><li>方法 <code>findFromEnd()</code> ：返回链表的倒数第 k 个结点。</li><li>结点 x 用于存储链表的倒数第 n + 1 个结点</li></ul><p>🌟 在链表的头部添加一个虚拟结点 dummy：可以避免删除倒数第一个元素时出现空指针异常。</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(-1);        dummy.next = head;        // 删除倒数第 n 个，要先找倒数第 n + 1 个结点        ListNode x = findFromEnd(dummy, n + 1);        x.next = x.next.next;        return dummy.next;    &#125;    // 返回链表的倒数第 k 个结点    private ListNode findFromEnd(ListNode head, int k) &#123;        ListNode p1 = head;        for (int i = 0; i &lt; k; i++) &#123;            p1 = p1.next;        &#125;        ListNode p2 = head;        while (p1 != null) &#123;            p1 = p1.next;            p2 = p2.next;        &#125;        return p2;    &#125;&#125;</code></pre><h1 id="21- 合并两个有序链表"><a href="#21- 合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表 </h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/"> 题源：21. 合并两个有序链表</a></p><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。 </p></blockquote><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置两个指针 p1 和 p2，分别指向链表的两个头结点。</li><li>让指针 p1 和 p2 分别在两个链表上遍历，每次都比较两个指针所指向的结点的值：<ul><li>若指针 p1 指向的结点值小于指针 p2 指向的结点值，则将指针 p1 指向的结点加入到新合并的链表中，并将指针 p1 往前移动一步；</li><li>若指针 p1 指向的结点值大于指针 p2 指向的结点值，则将指针 p2 指向的结点加入到新合并的链表中，并将指针 p2 往前移动一步；</li></ul></li></ul><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><p>🌟 在链表的头部添加一个虚拟结点 dummy：可以避免出现空指针异常、简化代码。</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode dummy = new ListNode(-1);        ListNode p = dummy;        ListNode p1 = list1, p2 = list2;        while (p1 != null &amp;&amp; p2 != null) &#123;            if (p1.val &gt; p2.val) &#123;                p.next = p2;                p2= p2.next;            &#125; else &#123;                p.next = p1;                p1= p1.next;            &#125;            p = p.next;        &#125;        if (p1 != null) p.next = p1;        if (p2 != null) p.next = p2;        return dummy.next;    &#125;&#125;</code></pre><h1 id="23- 合并 -K- 个升序链表"><a href="#23- 合并 -K- 个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表 </h1><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/"> 题源：23. 合并 K 个升序链表</a></p><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><ul><li>采用优先队列 <code>PriorityQueue</code> 实现小顶堆。</li><li>将 k 个链表的头结点加入到最小堆中：<ul><li>当优先队列不为空时，每次获取最小结点，加入到结果链表中。</li></ul></li></ul><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><ul><li><code>PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(lists.length, (a, b)-&gt;(a.val - b.val));</code>采用 lambda 表达式实现小顶堆。</li><li>设置虚拟头结点 dummy。</li></ul><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode mergeKLists(ListNode[] lists) &#123;        if (lists.length == 0) return null;        ListNode dummy = new ListNode(-1);        ListNode p = dummy;        PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(lists.length, (a, b)-&gt;(a.val - b.val)        );        for (ListNode head : lists) &#123;            if (head != null) &#123;                pq.add(head);            &#125;        &#125;        while (!pq.isEmpty()) &#123;            ListNode node = pq.poll();            p.next = node;            if (node.next != null) &#123;                pq.add(node.next);            &#125;            p = p.next;        &#125;        return dummy.next;    &#125;&#125;</code></pre><h1 id="86- 分隔链表"><a href="#86- 分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表 </h1><p><a href="https://leetcode.cn/problems/partition-list/"> 题源：86. 分隔链表</a></p><blockquote><p>给你一个链表的头结点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的结点都出现在 大于或等于 x 的结点之前。</p><p>你应当 保留 两个分区中每个结点的初始相对位置。</p></blockquote><h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置两个虚拟头结点 dummy1 和 dummy2，设置两个指针 p1 和 p2，让两个指针分别指向两个 dummy 结点。</li><li>遍历给定的链表，判断每个遍历的结点：<ul><li>如果当前结点的值小于给定的数值 x，将该结点接到 dummy1 结点所在链表，并将指针 p1 向前移动一步；</li><li>如果当前结点的值大于给定的数值 x，将该结点接到 dummy2 结点所在链表，并将指针 p2 向前移动一步。</li><li>进入下一个循环进行判断。</li></ul></li><li>将 dummy2 所在链表拼接到 dummy1 所在链表之前，并将尾结点的后继结点设为 null。</li></ul><p>🌟 <code>p2.next = null;</code>是关键，没写可能导致超出内存限制。 </p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;                ListNode dummy1 = new ListNode(-1);          ListNode dummy2 = new ListNode(-1);          ListNode p1 = dummy1, p2 = dummy2;          ListNode p = head;          while (p != null) &#123;              if (p.val &lt; x) &#123;                    p1.next = p;                  p1 = p1.next;              &#125; else &#123;                  p2.next = p;                  p2 = p2.next;            &#125;              p = p.next;        &#125;          p1.next = dummy2.next;          p2.next = null;          return dummy1.next;    &#125;&#125;</code></pre><h1 id="876- 链表的中间结点"><a href="#876- 链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点 </h1><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/"> 题源：876. 链表的中间结点</a></p><blockquote><p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p></blockquote><h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置快、慢指针向前移动的速度分别为 2v、v。</li><li>快指针每次移动两步，慢指针每次移动一步，当快指针移动到链表末尾时，慢指针恰好位于链表中点。</li></ul><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode middleNode(ListNode head) &#123;        ListNode fast = head, slow = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        return slow;    &#125;&#125;</code></pre><h1 id="83- 删除排序链表中的重复元素"><a href="#83- 删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素 </h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/"> 题源：83. 删除排序链表中的重复元素</a></p><blockquote><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次 </em> 。返回 <em> 已排序的链表</em> 。</p></blockquote><h2 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h2><ul><li>思路同 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">26. 删除有序数组中的重复项</a> 。</li><li>唯一的区别是把数组赋值操作变成操作指针而已。</li></ul><h2 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h2><ul><li><code>slow.next = fast;</code> 相当于  <code>nums[slow] = nums[fast];</code>                </li><li><code>slow = slow.next;</code> 相当于 <code>slow++;</code></li><li><code>fast = fast.next;</code> 相当于 <code>fast++;</code></li></ul><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        if (head == null) return null;        ListNode slow = head, fast = head;        while (fast != null) &#123;            if (fast.val != slow.val) &#123;                slow.next = fast;                slow = slow.next;            &#125;            fast = fast.next;        &#125;        slow.next = null;        return head;    &#125;&#125;</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/">labuladong 的算法小抄 - 双指针技巧秒杀七道链表题目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to My HomePage!</title>
      <link href="/2023/02/28/hello-world/"/>
      <url>/2023/02/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring 框架之设计模式</title>
      <link href="/2023/02/20/spring_dm/"/>
      <url>/2023/02/20/spring_dm/</url>
      
        <content type="html"><![CDATA[<h1 id="1- 工厂模式"><a href="#1- 工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h1><h2 id="1-1- 简单工厂模式"><a href="#1-1- 简单工厂模式" class="headerlink" title="1.1 简单工厂模式"></a>1.1 简单工厂模式</h2><p>Spring 中的 BeanFactory ，根据传入一个唯一的标识来获取 Bean 对象。</p><h2 id="1-2- 工厂方法模式"><a href="#1-2- 工厂方法模式" class="headerlink" title="1.2 工厂方法模式"></a>1.2 工厂方法模式</h2><p>FactoryBean 接口，实现了该接口的 bean 是一类叫做 factory 的 bean。</p><p>Spring 在调用方法 getBean() 来获取 bean 时，会自动调用该 bean 的方法 getObject()来获取该工厂 bean 产生的实例，而非工厂 bean 本身实例</p><p>典型示例：Spring 整合 MyBatis</p><h1 id="2- 代理模式"><a href="#2- 代理模式" class="headerlink" title="2. 代理模式"></a>2. 代理模式</h1><p>Spring AOP 的功能即为采用动态代理实现的，支持 JdkDynamicAopProxy 和 Cglib2AopProxy。</p><h1 id="3- 单例模式"><a href="#3- 单例模式" class="headerlink" title="3. 单例模式"></a>3. 单例模式 </h1><p> 一个类在整个系统运行的过程中，只允许产生一个实例。</p><p>Spring 依赖注入的 Bean 默认是单例的。</p><h1 id="4- 模版方法模式"><a href="#4- 模版方法模式" class="headerlink" title="4. 模版方法模式"></a>4. 模版方法模式</h1><p>Spring 中的 JdbcTemplate 等以 Template 结尾的类均采用模版方法模式。</p><h1 id="5- 观察者模式"><a href="#5- 观察者模式" class="headerlink" title="5. 观察者模式"></a>5. 观察者模式</h1><p>Spring 事件驱动模式即为观察者模式的经典应用。</p><h1 id="6- 装饰器模式"><a href="#6- 装饰器模式" class="headerlink" title="6. 装饰器模式"></a>6. 装饰器模式 </h1><p> 缓存与数据库搭配使用时，可能出现以下情况：缓存写操作成功，但数据库事务回滚了，造成了脏数据的问题。Spring 的 TransactionAwareCacheDecorator 使用装饰器模式，增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理，解决了脏数据问题。</p><h1 id="7- 策略模式"><a href="#7- 策略模式" class="headerlink" title="7. 策略模式"></a>7. 策略模式</h1><p>Spring 通过策略模式在运行时动态地选择不同的动态代理实现方式。</p><h1 id="8- 适配器模式"><a href="#8- 适配器模式" class="headerlink" title="8. 适配器模式"></a>8. 适配器模式</h1><p>Spring MVC 采用适配器模式适配 Controller。 Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法对请求进行处理。如果不用适配器模式，DispatcherServlet 则需要写一堆 if-else 逻辑来调用对应 Controller 的请求处理方法。</p><p>采用适配器模式后，可以将不同方式定义的 Controller 类中的方法适配为统一的函数定义。这样即可在 DispatcherServlet 类中代码中，移除 if-else 分支判断逻辑，而调用统一的函数。</p><h1 id="9- 责任链模式"><a href="#9- 责任链模式" class="headerlink" title="9. 责任链模式"></a>9. 责任链模式 </h1><p> 将能够处理同一类请求的对象连成一条链，使这些对象均有机会处理请求，所提交的请求沿着链传递，避免请求的发送者和接收者之间产生耦合关系。</p><p>典型示例：Spring 拦截器</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 算法笔记之二叉树</title>
      <link href="/2023/01/15/tree/"/>
      <url>/2023/01/15/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="104- 二叉树的最大深度"><a href="#104- 二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度 </h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/"> 题源：104. 二叉树的最大深度</a></p><blockquote><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1- 动态规划"><a href="#Solution-1- 动态规划" class="headerlink" title="Solution 1: 动态规划"></a>Solution 1: 动态规划</h3><ul><li>输入一个节点，返回以该节点为根的二叉树的最大深度。</li><li>根据左、右子树的最大深度得到原二叉树的最大深度。</li></ul><h3 id="Solution-2- 回溯"><a href="#Solution-2- 回溯" class="headerlink" title="Solution 2: 回溯"></a>Solution 2: 回溯</h3><ul><li>遍历二叉树，在遍历的过程中记录最大深度。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Code-1- 动态规划"><a href="#Code-1- 动态规划" class="headerlink" title="Code 1: 动态规划"></a>Code 1: 动态规划</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        int leftMax = maxDepth(root.left);        int rightMax = maxDepth(root.right);        return 1 + Math.max(leftMax, rightMax);    &#125;&#125;</code></pre><h3 id="Code-2- 回溯"><a href="#Code-2- 回溯" class="headerlink" title="Code 2: 回溯"></a>Code 2: 回溯</h3><ul><li>新增类的成员变量：<ul><li>res 用于记录最大深度；</li><li>depth 用于记录遍历到的节点的深度。</li></ul></li><li><h2 id="新增方法 -traverse-：遍历二叉树。"><a href="# 新增方法 -traverse-：遍历二叉树。" class="headerlink" title="新增方法 traverse() ：遍历二叉树。"></a>新增方法 <code>traverse()</code> ：遍历二叉树。</h2></li></ul><pre><code class="java">class Solution &#123;    int depth = 0;    int res = 0;    public int maxDepth(TreeNode root) &#123;        traverse(root);        return res;    &#125;    void traverse(TreeNode root) &#123;        if (root == null) return;        depth++;        res = Math.max(res, depth);        traverse(root.left);        traverse(root.right);        depth--;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 算法笔记之数组 (双指针解法)</title>
      <link href="/2023/01/01/array/"/>
      <url>/2023/01/01/array/</url>
      
        <content type="html"><![CDATA[<h1 id="167- 两数之和 -II- 输入有序数组"><a href="#167- 两数之和 -II- 输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组 </h1><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/"> 题源：167. 两数之和 II - 输入有序数组</a></p><blockquote><p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。</p><p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li><p>设置双指针，左指针指向数组第一个元素，右指针指向数组最后一个元素。</p></li><li><p>将两个指针所指向的元素相加，得到一个和 sum，比较 sum 与 给定的目标和 target 的大小：</p><ul><li>若 sum 等于 target，则返回得到两个元素的数组下标；</li><li>若 sum 小于 target，则左指针右移一位；</li><li>若 sum 大于 target，则右指针左移一位。</li></ul></li><li><p>若找不到符合条件的元素，则返回数组 [-1, -1]。</p></li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        int l = 0;        int r = numbers.length - 1;        while (l &lt; r) &#123;            int sum = numbers[l] + numbers[r];            if (sum == target) &#123;                return new int[]&#123;l + 1, r + 1&#125;;            &#125; else if (sum &lt; target) &#123;                l++;            &#125; else &#123;                r--;            &#125;        &#125;        return new int[]&#123;-1, -1&#125;;    &#125;&#125;</code></pre><h1 id="26- 删除有序数组中的重复项"><a href="#26- 删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项 </h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/"> 题源：26. 删除有序数组中的重复项</a></p><blockquote><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组 nums 的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p></blockquote><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置快、慢指针，让快指针在前，慢指针在后：<ul><li>快指针每找到一个与慢指针不同的元素，就让慢指针向前移动一步并在当前位置元素替换为快指针所指向的元素。</li><li>快指针若找不到非重复元素，则一直向前移动直至数组末尾。</li></ul></li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><ul><li><code>slow + 1</code> 表示最终返回的数组长度为慢指针所指向的元素数组下标 + 1。</li></ul><pre><code class="java">class Solution &#123;    public int removeDuplicates(int[] nums) &#123;        if (nums.length == 0) return 0;        int slow = 0, fast = 0;        while (fast &lt; nums.length) &#123;            if (nums[fast] != nums[slow]) &#123;                slow++;                nums[slow] = nums[fast];            &#125;            fast++;        &#125;        return slow + 1;    &#125;&#125;</code></pre><h1 id="27- 移除元素"><a href="#27- 移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素 </h1><p><a href="https://leetcode.cn/problems/remove-element/"> 题源：27. 移除元素</a></p><blockquote><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置快慢、指针：<ul><li>如果快指针遇到需要去除的元素，则直接跳过；</li><li>否则就告诉慢指针，并让慢指针前进一步。</li></ul></li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public int removeElement(int[] nums, int val) &#123;        int slow = 0, fast = 0;        while (fast &lt; nums.length) &#123;            if (nums[fast] != val) &#123;                nums[slow] = nums[fast];                slow++;            &#125;            fast++;        &#125;        return slow;    &#125;&#125;</code></pre><h1 id="283- 移动零"><a href="#283- 移动零" class="headerlink" title="283. 移动零"></a>283. 移动零 </h1><p><a href="https://leetcode.cn/problems/move-zeroes/"> 题源：283. 移动零</a></p><blockquote><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p></blockquote><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>可以直接复用 <a href="https://leetcode.cn/problems/remove-element">27. 移除元素</a> 的解法，先移除所有 0，然后把最后的元素都置为 0，就相当于移动 0 的效果。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><ul><li>新增方法 <code>removeElement()</code> ，直接复用 <a href="https://leetcode.cn/problems/remove-element">27. 移除元素</a> 的解法。</li></ul><pre><code class="java">class Solution &#123;    public void moveZeroes(int[] nums) &#123;        int p = removeElement(nums, 0);        for (; p &lt; nums.length; p++) &#123;            nums[p] = 0;        &#125;    &#125;    int removeElement(int[] nums, int val) &#123;        int fast = 0, slow = 0;        while (fast &lt; nums.length) &#123;            if (nums[fast] != val) &#123;                nums[slow] = nums[fast];                slow++;            &#125;            fast++;        &#125;        return slow;    &#125;&#125;</code></pre><h1 id="344- 反转字符串"><a href="#344- 反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串 </h1><p><a href="https://leetcode.cn/problems/reverse-string/"> 题源：344. 反转字符串</a></p><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p></blockquote><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置左右指针，分别从字符数组的两端开始遍历并交换。</li></ul><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public void reverseString(char[] s) &#123;        int l = 0, r = s.length - 1;        while (l &lt; r) &#123;            char temp = s[l];            s[l] = s[r];            s[r] = temp;            l++;            r--;        &#125;    &#125;&#125;</code></pre><h1 id="5- 最长回文子串"><a href="#5- 最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串 </h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/"> 题源：5. 最长回文子串</a></p><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p></blockquote><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><ul><li>核心思想：从中间开始向两边扩散来判断回文串</li></ul><pre><code>for 0 &lt;= i &lt; len(s):        找到以 s[i] 为中心的回文串    更新答案</code></pre><ul><li>设置左、右指针并向两边扩散：</li></ul><pre><code>for 0 &lt;= i &lt; len(s):    # 找到以 s[i] 为中心的回文串    palindrome(s, i, i)    # 找到以 s[i] 和 s[i+1] 为中心的回文串    palindrome(s, i, i + 1)    更新答案</code></pre><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><ul><li>新增方法 <code>palindrome()</code> :<ul><li>while 循环内条件：防止索引越界。</li><li><code>return s.substring(l + 1, r);</code> 返回以 s[l] 和 s[r] 为中心的最长回文串。</li></ul></li><li>方法 <code>longestPalindrome()</code> ：<ul><li><code>String s1 = palindrome(s, i, i);</code> 代表以 s[i] 为中心的最长回文子串 (针对回文串长度为奇数的情况)；</li><li><code>String s2 = palindrome(s, i, i + 1);</code> 代表以 s[i] 和 s[i+1] 为中心的最长回文子串 (针对回文串长度为偶数的情况)。</li></ul></li></ul><pre><code class="java">class Solution &#123;    public String longestPalindrome(String s) &#123;        String res = &quot;&quot;;        for (int i = 0; i &lt; s.length(); i++) &#123;            String s1 = palindrome(s, i, i);            String s2 = palindrome(s, i, i + 1);            res = res.length() &gt; s1.length() ? res : s1;            res = res.length() &gt; s2.length() ? res : s2;        &#125;        return res;    &#125;    String palindrome(String s, int l, int r) &#123;        while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;            l--;            r++;        &#125;        return s.substring(l + 1, r);    &#125;&#125;</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/shuang-zhi-fa4bd/">labuladong 的算法小抄 - 双指针技巧秒杀七道数组题目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
