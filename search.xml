<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>校园社区论坛项目之 ElasticSearch</title>
      <link href="/2023/03/07/ElasticSearch/"/>
      <url>/2023/03/07/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h1><ul><li>一个分布式的、Restful 风格的搜索引擎。 </li><li>支持对各种类型的数据的检索。 </li><li>搜索速度快，可以提供实时的搜索服务。 </li><li>便于水平扩展，每秒可以处理 PB 级海量数据。 </li><li>Elasticsearch 术语<ul><li>索引、类型、文档、字段</li><li>集群、节点、分片、副本。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Kafka</title>
      <link href="/2023/03/07/community5/"/>
      <url>/2023/03/07/community5/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Kafka 实现校园社区论坛项目的发送系统通知、显示系统通知的功能。</p><p>🌟 准备工作：</p><ol><li>引入 Kafka 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在 application.properties 文件中配置 Kafka 的 server 和 consumer：</li></ol><pre><code class="properties"># KafkaPropertiesspring.kafka.bootstrap-servers=localhost:9092spring.kafka.consumer.group-id=community-consumer-groupspring.kafka.consumer.enable-auto-commit=truespring.kafka.consumer.auto-commit-interval=3000</code></pre><ol start="3"><li>访问 Kafka：</li></ol><p>生产者</p><pre><code>kafkaTemplate.send(topic, data);</code></pre><p>消费者</p><pre><code>@KafkaListener(topic = &#123;&quot;test&quot;&#125;)</code></pre><pre><code>public void handleMessage(ConsumerRecord record)&#123;&#125;</code></pre><h1 id="1-发送系统通知"><a href="#1-发送系统通知" class="headerlink" title="1. 发送系统通知"></a>1. 发送系统通知</h1><ol><li>触发事件：评论后发布通知；点赞后发布通知；关注后发布通知。</li><li>处理事件：封装事件对象；开发事件的生产者；开发事件的消费者。</li></ol><h2 id="创建实体类-Event"><a href="#创建实体类-Event" class="headerlink" title="创建实体类 Event"></a>创建实体类 Event</h2><ul><li>封装事件对象，包括主题、用户 id、实体类型、实体 id、实体用户 id 以及一个 map 集合存放其它信息。</li></ul><pre><code class="java">public class Event &#123;    private String topic;    private int userId;    private int entityType;    private int entityId;    private int entityUserId;    private Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();    public String getTopic() &#123;        return topic;    &#125;    public Event setTopic(String topic) &#123;        this.topic = topic;        return this;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public Event setUserId(int userId) &#123;        this.userId = userId;        return this;    &#125;    public int getEntityType() &#123;        return entityType;    &#125;    public Event setEntityType(int entityType) &#123;        this.entityType = entityType;        return this;    &#125;    public int getEntityId() &#123;        return entityId;    &#125;    public Event setEntityId(int entityId) &#123;        this.entityId = entityId;        return this;    &#125;    public int getEntityUserId() &#123;        return entityUserId;    &#125;    public Event setEntityUserId(int entityUserId) &#123;        this.entityUserId = entityUserId;        return this;    &#125;    public Map&lt;String, Object&gt; getData() &#123;        return data;    &#125;    public Event setData(String key, Object value) &#123;        this.data.put(key, value);        return this;    &#125;&#125;</code></pre><h2 id="更新接口-CommunityConstant"><a href="#更新接口-CommunityConstant" class="headerlink" title="更新接口 CommunityConstant"></a>更新接口 CommunityConstant</h2><ul><li>在接口中新增三个常量，代表三个主题：评论、点赞、关注。</li></ul><pre><code class="java">/** * 主题: 评论 */String TOPIC_COMMENT = &quot;comment&quot;;/** * 主题: 点赞 */String TOPIC_LIKE = &quot;like&quot;;/** * 主题: 关注 */String TOPIC_FOLLOW = &quot;follow&quot;;</code></pre><h2 id="创建事件生产者类-EventProducer"><a href="#创建事件生产者类-EventProducer" class="headerlink" title="创建事件生产者类 EventProducer"></a>创建事件生产者类 EventProducer</h2><ul><li>新增方法 <code>fireEvent(Event event)</code> ：通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的方法 <code>send()</code> 发送。</li></ul><pre><code class="java">@Componentpublic class EventProducer &#123;    @Autowired    private KafkaTemplate kafkaTemplate;    // 处理事件    public void fireEvent(Event event) &#123;        // 将事件发布到指定的主题        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));    &#125;&#125;</code></pre><h2 id="更新表现层的-CommentController、LikeController、FollowController"><a href="#更新表现层的-CommentController、LikeController、FollowController" class="headerlink" title="更新表现层的 CommentController、LikeController、FollowController"></a>更新表现层的 CommentController、LikeController、FollowController</h2><ul><li>注入 EventProducer 实例。</li><li>重构表现层 CommentController 类的方法 <code>addComment()</code>  ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/add/&#123;discussPostId&#125;&quot;)public String addComment(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Comment comment) &#123;    comment.setUserId(hostHolder.getUser().getId());    comment.setStatus(0);    comment.setCreateTime(new Date());    commentService.addComment(comment);    // 触发评论事件    Event event = new Event()            .setTopic(TOPIC_COMMENT)            .setUserId(hostHolder.getUser().getId())            .setEntityType(comment.getEntityType())            .setEntityId(comment.getEntityId())            .setData(&quot;postId&quot;, discussPostId);    if (comment.getEntityType() == ENTITY_TYPE_POST) &#123;        DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125; else if (comment.getEntityType() == ENTITY_TYPE_COMMENT) &#123;        Comment target = commentService.findCommentById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125;    eventProducer.fireEvent(event);    return &quot;redirect:/discuss/detail/&quot; + discussPostId;&#125;</code></pre><ul><li>重构表现层 LikeController 类的方法 <code>like()</code>  ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/like&quot;)@ResponseBodypublic String like(int entityType, int entityId, int entityUserId, int postId) &#123;    User user = hostHolder.getUser();    // 点赞    likeService.like(user.getId(), entityType, entityId, entityUserId);    // 数量    long likeCount = likeService.findEntityLikeCount(entityType, entityId);    // 状态    int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);    // 返回的结果    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;likeCount&quot;, likeCount);    map.put(&quot;likeStatus&quot;, likeStatus);    // 触发点赞事件    if (likeStatus == 1) &#123;        Event event = new Event()                .setTopic(TOPIC_LIKE)                .setUserId(hostHolder.getUser().getId())                .setEntityType(entityType)                .setEntityId(entityId)                .setEntityUserId(entityUserId)                .setData(&quot;postId&quot;, postId);        eventProducer.fireEvent(event);    &#125;    return CommunityUtil.getJSONString(0, null, map);&#125;</code></pre><ul><li>重构表现层 FollowController 类的方法 <code>follow()</code> ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/follow&quot;)@ResponseBodypublic String follow(int entityType, int entityId) &#123;    User user = hostHolder.getUser();    followService.follow(user.getId(), entityType, entityId);    // 触发关注事件    Event event = new Event()            .setTopic(TOPIC_FOLLOW)            .setUserId(hostHolder.getUser().getId())            .setEntityType(entityType)            .setEntityId(entityId)            .setEntityUserId(entityId);    eventProducer.fireEvent(event);    return CommunityUtil.getJSONString(0, &quot;已关注!&quot;);&#125;</code></pre><h2 id="创建事件消费者类-EventConsumer"><a href="#创建事件消费者类-EventConsumer" class="headerlink" title="创建事件消费者类 EventConsumer"></a>创建事件消费者类 EventConsumer</h2><ul><li>注入 MessageService 实例。</li><li>新增方法 <code>handleCommentMessage(ConsumerRecord record)</code> ：通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 record 中获取信息，封装成 Message 对象然后调用方法 <code>addMessage()</code> 插入数据库。</li></ul><pre><code class="java">@Componentpublic class EventConsumer implements CommunityConstant &#123;    private static final Logger logger = LoggerFactory.getLogger(EventConsumer.class);    @Autowired    private MessageService messageService;    @KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)    public void handleCommentMessage(ConsumerRecord record) &#123;        if (record == null || record.value() == null) &#123;            logger.error(&quot;消息的内容为空!&quot;);            return;        &#125;        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) &#123;            logger.error(&quot;消息格式错误!&quot;);            return;        &#125;        // 发送站内通知        Message message = new Message();        message.setFromId(SYSTEM_USER_ID);        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        message.setCreateTime(new Date());        Map&lt;String, Object&gt; content = new HashMap&lt;&gt;();        content.put(&quot;userId&quot;, event.getUserId());        content.put(&quot;entityType&quot;, event.getEntityType());        content.put(&quot;entityId&quot;, event.getEntityId());        if (!event.getData().isEmpty()) &#123;            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;                content.put(entry.getKey(), entry.getValue());            &#125;        &#125;        message.setContent(JSONObject.toJSONString(content));        messageService.addMessage(message);    &#125;&#125;</code></pre><h1 id="2-显示系统通知"><a href="#2-显示系统通知" class="headerlink" title="2. 显示系统通知"></a>2. 显示系统通知</h1><ol><li>通知列表：显示评论、点赞、关注三种类型的通知。</li><li>通知详情：分页显示某一类主题所包含的通知。</li><li>未读消息：在页面头部显示所有未读消息的数量。</li></ol><h2 id="更新接口-MessageMapper"><a href="#更新接口-MessageMapper" class="headerlink" title="更新接口 MessageMapper"></a>更新接口 MessageMapper</h2><ul><li>新增方法 <code>selectLatestNotice(int userId, String topic)</code> ，查询某主题最新的通知。</li><li>新增方法 <code>selectNoticeCount(int userId, String topic)</code> ，查询某主题通知的数量。</li><li>新增方法 <code>selectNoticeUnreadCount(int userId, String topic)</code> ，查询未读通知的数量。</li></ul><pre><code class="java">// 查询某个主题下最新的通知Message selectLatestNotice(int userId, String topic);// 查询某个主题所包含的通知数量int selectNoticeCount(int userId, String topic);// 查询未读的通知的数量int selectNoticeUnreadCount(int userId, String topic);</code></pre><ul><li>在 <code>message-mapper.xml</code> 配置三个方法的 sql 语句，其中查询未读通知时使用 if 动态语句，如果没有传入 topic 就查询未读总量。</li></ul><pre><code class="xml">&lt;sql id=&quot;selectFields&quot;&gt;    id, from_id, to_id, conversation_id, content, status, create_time&lt;/sql&gt;&lt;select id=&quot;selectLatestNotice&quot; resultType=&quot;Message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where id in (        select max(id) from message        where status != 2        and from_id = 1        and to_id = #&#123;userId&#125;        and conversation_id = #&#123;topic&#125;    )&lt;/select&gt;&lt;select id=&quot;selectNoticeCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;&lt;/select&gt;&lt;select id=&quot;selectNoticeUnreadCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status = 0    and from_id = 1    and to_id = #&#123;userId&#125;    &lt;if test=&quot;topic!=null&quot;&gt;        and conversation_id = #&#123;topic&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre><h2 id="更新业务层的-MessageService-类"><a href="#更新业务层的-MessageService-类" class="headerlink" title="更新业务层的 MessageService 类"></a>更新业务层的 MessageService 类</h2><ul><li>新增方法 <code>findLatestNotice()</code> ，调用方法 <code>selectLatestNotice()</code> 查询最新通知。</li><li>新增方法 <code>findNoticeCount()</code> ，调用方法 <code>selectNoticeCount()</code> 查询某主题通知的数量。</li><li>新增方法 <code>findNoticeUnreadCount()</code> ，调用方法 <code>selectNoticeUnreadCount()</code> 查询未读通知的数量。</li></ul><pre><code class="java">public Message findLatestNotice(int userId, String topic) &#123;    return messageMapper.selectLatestNotice(userId, topic);&#125;public int findNoticeCount(int userId, String topic) &#123;    return messageMapper.selectNoticeCount(userId, topic);&#125;public int findNoticeUnreadCount(int userId, String topic) &#123;    return messageMapper.selectNoticeUnreadCount(userId, topic);&#125;</code></pre><h2 id="更新表现层的-MessageController-类"><a href="#更新表现层的-MessageController-类" class="headerlink" title="更新表现层的 MessageController 类"></a>更新表现层的 MessageController 类</h2><ul><li>新增方法 <code>getNoticeList()</code> ：获取通知列表。<ul><li>调用业务层的 MessageService 类的方法查询评论、点赞、关注的通知，将其封装在一个 HashMap 集合中然后添加到 Model 对象中。</li><li>调用业务层的 MessageService 类的方法查询私信和通知的总未读数量，添加到 Model 对象中。</li><li>返回 <code>notice.html</code> 页面。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/notice/list&quot;)public String getNoticeList(Model model) &#123;    User user = hostHolder.getUser();    // 查询评论类通知    Message message = messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);    Map&lt;String, Object&gt; messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;commentNotice&quot;, messageVO);    // 查询点赞类通知    message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);    messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_LIKE);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;likeNotice&quot;, messageVO);    // 查询关注类通知    message = messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);    messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;followNotice&quot;, messageVO);    // 查询私信的总未读数    int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);    model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);      // 查询通知的总未读数    int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);    model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);    return &quot;/site/notice&quot;;&#125;</code></pre><h2 id="再次更新接口-MessageMapper"><a href="#再次更新接口-MessageMapper" class="headerlink" title="再次更新接口 MessageMapper"></a>再次更新接口 MessageMapper</h2><ul><li>新增方法 <code>selectNotices()</code> ：查询某个主题的通知列表。</li><li>在 <code>message-mapper.xml</code> 文件中配置 SQL。</li></ul><pre><code class="java">// 查询某个主题所包含的通知列表List&lt;Message&gt; selectNotices(int userId, String topic, int offset, int limit);</code></pre><pre><code class="xml">&lt;select id=&quot;selectNotices&quot; resultType=&quot;Message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;    order by create_time desc    limit #&#123;offset&#125;, #&#123;limit&#125;&lt;/select&gt;</code></pre><h2 id="再次更新业务层的-MessageService-类"><a href="#再次更新业务层的-MessageService-类" class="headerlink" title="再次更新业务层的 MessageService 类"></a>再次更新业务层的 MessageService 类</h2><p>新增方法 <code>findNotices()</code> ：调用方法 <code>selectNotices()</code> 。</p><pre><code class="java">public List&lt;Message&gt; findNotices(int userId, String topic, int offset, int limit) &#123;    return messageMapper.selectNotices(userId, topic, offset, limit);&#125;</code></pre><h2 id="再次更新业务层的-MessageController-类"><a href="#再次更新业务层的-MessageController-类" class="headerlink" title="再次更新业务层的 MessageController 类"></a>再次更新业务层的 MessageController 类</h2><ul><li>新增方法 <code>getNoticeDetail()</code> ：<ul><li>调用方法 <code>findNotices()</code> 获取通知列表详情，封装到 List 集合并存入 Model 对象。</li><li>从通知集合中获取 id 集合，调用方法 <code>readMessage()</code> 将消息设为已读。</li><li>返回 <code>notice-detail.html</code> 页面。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/notice/detail/&#123;topic&#125;&quot;)public String getNoticeDetail(@PathVariable(&quot;topic&quot;) String topic, Page page, Model model) &#123;    User user = hostHolder.getUser();    page.setLimit(5);    page.setPath(&quot;/notice/detail/&quot; + topic);    page.setRows(messageService.findNoticeCount(user.getId(), topic));    List&lt;Message&gt; noticeList = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; noticeVoList = new ArrayList&lt;&gt;();    if (noticeList != null) &#123;        for (Message notice : noticeList) &#123;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            // 通知            map.put(&quot;notice&quot;, notice);            // 内容            String content = HtmlUtils.htmlUnescape(notice.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            map.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));            map.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));            map.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));            map.put(&quot;postId&quot;, data.get(&quot;postId&quot;));            // 通知作者            map.put(&quot;fromUser&quot;, userService.findUserById(notice.getFromId()));            noticeVoList.add(map);        &#125;    &#125;    model.addAttribute(&quot;notices&quot;, noticeVoList);    // 设置已读    List&lt;Integer&gt; ids = getLetterIds(noticeList);    if (!ids.isEmpty()) &#123;        messageService.readMessage(ids);    &#125;    return &quot;/site/notice-detail&quot;;&#125;</code></pre><h2 id="创建表现层的拦截器-MessageInterceptor-类"><a href="#创建表现层的拦截器-MessageInterceptor-类" class="headerlink" title="创建表现层的拦截器 MessageInterceptor 类"></a>创建表现层的拦截器 MessageInterceptor 类</h2><ul><li>注入 MessageService 实例和 HostHolder 实例。</li><li>重写方法 <code>postHandle()</code> ，查询私信和通知的未读数量和，然后添加到 ModelAndView 对象。</li></ul><pre><code class="java">@Componentpublic class MessageInterceptor implements HandlerInterceptor &#123;    @Autowired    private HostHolder hostHolder;    @Autowired    private MessageService messageService;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        User user = hostHolder.getUser();        if (user != null &amp;&amp; modelAndView != null) &#123;            int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);            int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);            modelAndView.addObject(&quot;allUnreadCount&quot;, letterUnreadCount + noticeUnreadCount);        &#125;    &#125;&#125;</code></pre><h2 id="更新配置类-WebConfig"><a href="#更新配置类-WebConfig" class="headerlink" title="更新配置类 WebConfig"></a>更新配置类 WebConfig</h2><ul><li>注入 MessageInterceptor 实例。</li><li>在方法 <code>addInterceptors()</code> 中添加拦截器 MessageInterceptor 实例。</li></ul><pre><code class="java">@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(alphaInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;)            .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;);    registry.addInterceptor(loginTicketInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    registry.addInterceptor(loginRequiredInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    registry.addInterceptor(messageInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Redis</title>
      <link href="/2023/03/07/community4/"/>
      <url>/2023/03/07/community4/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Redis 实现校园社区论坛项目的点赞、关注功能，同时优化了登录模块中的验证码存储、登录凭证存储、用户信息缓存功能。</p><p>🌟 准备工作：</p><ol><li>引入 Redis 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在 application.properties 文件中配置 Redis：</li></ol><pre><code class="properties"># RedisPropertiesspring.redis.database=11spring.redis.host=localhostspring.redis.port=6379</code></pre><ol start="3"><li>编写配置类 RedisConfig：</li></ol><pre><code class="java">@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        // 设置 key 的序列化方式        template.setKeySerializer(RedisSerializer.string());        // 设置 value 的序列化方式        template.setValueSerializer(RedisSerializer.json());        // 设置 hash 的 key 的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        // 设置 hash 的 value 的序列化方式        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        return template;    &#125;&#125;</code></pre><h1 id="1-点赞"><a href="#1-点赞" class="headerlink" title="1. 点赞"></a>1. 点赞</h1><p>点赞模块包含：</p><ol><li>点赞：(1)支持对帖子、评论进行点赞；(2)第一次点击“赞”完成点赞操作，第二次点击“已赞”完成取消点赞操作。</li><li>首页：统计帖子的点赞数。</li><li>详情页：(1)统计帖子的点赞数；(2)显示点赞状态。</li></ol><h2 id="创建工具类-RedisKeyUtil"><a href="#创建工具类-RedisKeyUtil" class="headerlink" title="创建工具类 RedisKeyUtil"></a>创建工具类 RedisKeyUtil</h2><ul><li>定义分隔符 <code>:</code></li><li>定义实体获得赞的 key 前缀常量  <code>like:entity</code></li><li>新增方法 <code>getEntityLikeKey(int entityType, int entityId)</code>，通过实体类型和实体 id 生成对应实体获得赞的 key，这个 key 的呈现形式为 <code>like:entity:entityType:entityId</code>。</li></ul><pre><code class="jade">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;&#125;</code></pre><h2 id="创建业务层的-LikeService-类"><a href="#创建业务层的-LikeService-类" class="headerlink" title="创建业务层的 LikeService 类"></a>创建业务层的 LikeService 类</h2><ul><li>注入 <code>RedisTemplate</code> 实例</li><li>新增方法 <code>like()</code> 实现点赞功能：<ul><li>首先，调用工具类 <code>RedisKeyUtil</code> 中的方法 <code>getEntityLikeKey()</code> 获得实体点赞的 key；</li><li>然后，通过 <code>RedisTemplate</code> 的对象，调用 set 集合的方法 <code>isMember()</code> 查询 userId 是否存在于对应 key 的 set 集合中，如果存在则移出点赞的用户集合，如果不存在则添加到点赞的用户集合中。</li></ul></li><li>新增方法 <code>findEntityLikeCount()</code>：查询某实体的点赞数，通过调用 set 集合的方法<code>size()</code>查询元素的个数。</li><li>新增方法 <code>findEntityLikeStatus()</code>：查询某用户对某实体的点赞状态，逻辑实现同方法<code>like()</code>，即通过调用 set 集合的方法 <code>isMember()</code> 实现。</li></ul><pre><code class="java">@Servicepublic class LikeService &#123;    @Autowired    private RedisTemplate redisTemplate;    // 点赞    public void like(int userId, int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);      // 判断是否点过赞        if (isMember) &#123;            redisTemplate.opsForSet().remove(entityLikeKey, userId);        &#125; else &#123;            redisTemplate.opsForSet().add(entityLikeKey, userId);        &#125;    &#125;    // 查询某实体点赞的数量    public long findEntityLikeCount(int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().size(entityLikeKey);    &#125;    // 查询某人对某实体的点赞状态    public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);          // 1 表示已赞；0表示未赞        return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;    &#125;&#125;</code></pre><h2 id="创建表现层的-LikeController-类"><a href="#创建表现层的-LikeController-类" class="headerlink" title="创建表现层的 LikeController 类"></a>创建表现层的 LikeController 类</h2><ul><li>注入 <code>LikeService</code> 和 <code>HostHolder</code> 实例</li><li>新增方法 <code>like()</code>：实现点赞功能，调用业务层的方法 <code>like()</code> 进行点赞，调用 <code>findEntityLikeCount()</code> 和 <code>findEntityLikeStatus()</code> 查询点赞数和点赞状态，并封装到 map 集合中，然后通过工具类封装成 JSON 数据返回。</li></ul><pre><code class="java">@Controllerpublic class LikeController &#123;    @Autowired    private LikeService likeService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/like&quot;)    @ResponseBody    public String like(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        // 点赞        likeService.like(user.getId(), entityType, entityId);        // 数量        long likeCount = likeService.findEntityLikeCount(entityType, entityId);        // 状态        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        // 返回的结果        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;, likeCount);        map.put(&quot;likeStatus&quot;, likeStatus);        return CommunityUtil.getJSONString(0, null, map);    &#125;&#125;</code></pre><h2 id="更新表现层的-HomeController-类"><a href="#更新表现层的-HomeController-类" class="headerlink" title="更新表现层的 HomeController 类"></a>更新表现层的 HomeController 类</h2><ul><li><p>注入  <code>LikeService</code> 实例</p></li><li><p>更新方法  <code>getIndexPage()</code>：新增更新首页帖子点赞数功能，调用业务层的 <code>LikeService</code> 类的方法获得点赞数，并存储到 map 集合中。</p></li></ul><pre><code class="java">@GetMapping(&quot;/index&quot;)public String getIndexPage(Model model, Page page) &#123;    // 方法调用之前，SpringMVC 会自动实例化 Model 和 Page，并将 Page 注入到 Model中。    // 所以，在 thymeleaf 中可以直接访问 Page 对象中的数据.    page.setRows(discussPostService.findDiscussPostRows(0));    page.setPath(&quot;/index&quot;);    List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;();    if (list != null) &#123;        for (DiscussPost post : list) &#123;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;post&quot;, post);            User user = userService.findUserById(post.getUserId());            map.put(&quot;user&quot;, user);            long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());            map.put(&quot;likeCount&quot;, likeCount);            discussPosts.add(map);        &#125;    &#125;    model.addAttribute(&quot;discussPosts&quot;, discussPosts);    return &quot;/index&quot;;&#125;</code></pre><h2 id="更新表现层的-DiscussPostController-类"><a href="#更新表现层的-DiscussPostController-类" class="headerlink" title="更新表现层的 DiscussPostController 类"></a>更新表现层的 DiscussPostController 类</h2><ul><li>注入  <code>LikeService</code> 实例</li><li>更新方法 <code>addDiscussPost()</code>：新增更新详情页帖子（评论、回复）的点赞数功能，调用业务层的 <code>LikeService</code> 类的方法获得点赞数和点赞状态，并将其存入视图对象中。</li></ul><pre><code class="java">@GetMapping(&quot;/detail/&#123;discussPostId&#125;&quot;)public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) &#123;    // 帖子    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);    model.addAttribute(&quot;post&quot;, post);    // 作者    User user = userService.findUserById(post.getUserId());    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    // 点赞状态    int likeStatus = hostHolder.getUser() == null ? 0 :            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);    model.addAttribute(&quot;likeStatus&quot;, likeStatus);    // 评论分页信息    page.setLimit(5);    page.setPath(&quot;/discuss/detail/&quot; + discussPostId);    page.setRows(post.getCommentCount());    // 评论: 给帖子的评论    // 回复: 给评论的评论    // 评论列表    List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(            ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());    // 评论VO列表    List&lt;Map&lt;String, Object&gt;&gt; commentVoList = new ArrayList&lt;&gt;();    if (commentList != null) &#123;        for (Comment comment : commentList) &#123;            // 评论VO            Map&lt;String, Object&gt; commentVo = new HashMap&lt;&gt;();            // 评论            commentVo.put(&quot;comment&quot;, comment);            // 作者            commentVo.put(&quot;user&quot;, userService.findUserById(comment.getUserId()));            // 点赞数量            likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;likeCount&quot;, likeCount);            // 点赞状态            likeStatus = hostHolder.getUser() == null ? 0 :                    likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;likeStatus&quot;, likeStatus);            // 回复列表            List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(                    ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);            // 回复VO列表            List&lt;Map&lt;String, Object&gt;&gt; replyVoList = new ArrayList&lt;&gt;();            if (replyList != null) &#123;                for (Comment reply : replyList) &#123;                    Map&lt;String, Object&gt; replyVo = new HashMap&lt;&gt;();                    // 回复                    replyVo.put(&quot;reply&quot;, reply);                    // 作者                    replyVo.put(&quot;user&quot;, userService.findUserById(reply.getUserId()));                    // 回复目标                    User target = reply.getTargetId() == 0 ? null : userService.findUserById(reply.getTargetId());                    replyVo.put(&quot;target&quot;, target);                    // 点赞数量                    likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());                    replyVo.put(&quot;likeCount&quot;, likeCount);                    // 点赞状态                    likeStatus = hostHolder.getUser() == null ? 0 :                            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());                    replyVo.put(&quot;likeStatus&quot;, likeStatus);                    replyVoList.add(replyVo);                &#125;            &#125;            commentVo.put(&quot;replys&quot;, replyVoList);            // 回复数量            int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;replyCount&quot;, replyCount);            commentVoList.add(commentVo);        &#125;    &#125;    model.addAttribute(&quot;comments&quot;, commentVoList);    return &quot;/site/discuss-detail&quot;;&#125;</code></pre><h1 id="2-收到的赞"><a href="#2-收到的赞" class="headerlink" title="2. 收到的赞"></a>2. 收到的赞</h1><ol><li>重构点赞功能：以用户为 key，记录点赞数量；<code>increment(key)</code>、<code>decrement(key)</code></li><li>开发个人主页：以用户为 key，查询点赞数。</li></ol><h2 id="更新工具类-RedisUtil"><a href="#更新工具类-RedisUtil" class="headerlink" title="更新工具类 RedisUtil"></a>更新工具类 RedisUtil</h2><ul><li><p>新增用户获得赞 key 的前缀常量 <code>like:user</code></p></li><li><p>新增方法 <code>getUserLikeKey(int userId)</code>，通过用户 id 生成对应用户获得赞的 key。</p></li></ul><pre><code class="java">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    private static final String PREFIX_USER_LIKE = &quot;like:user&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;    // 某个用户的赞    // like:user:userId -&gt; int    public static String getUserLikeKey(int userId) &#123;        return PREFIX_USER_LIKE + SPLIT + userId;    &#125;&#125;</code></pre><h2 id="更新业务层的-LikeService类"><a href="#更新业务层的-LikeService类" class="headerlink" title="更新业务层的 LikeService类"></a>更新业务层的 LikeService类</h2><ul><li>重构方法 <code>like()</code>，在参数列表中新增：entityUserId（表示被点赞用户的 id），该参数用来更新用户的被点赞数量。<ul><li>调用 <code>RedisTemplate</code> 的对象的方法 <code>execute()</code> 实现事务，保证被点赞用户与点赞用户的数据更新保持一致。调用 <code>isMember()</code> 查询用户的点赞状态，之后调用 <code>multi()</code> 开启事务。</li><li>当用户已点赞时，调用方法 <code>remove()</code> 将当前用户从点赞的用户集合中移除，调用方法 <code>decrement()</code> 将被点赞用户的被点赞数减去 1；当用户未点赞时，调用方法 <code>add()</code> 将当前用户添加到点赞的用户集合中，调用方法 <code>increment()</code> 将被点赞用户的点赞数加上 1。</li></ul></li><li>新增方法 <code>findUserLikeCount()</code>，以用户 id 为 key，调用方法 <code>get()</code> 查询用户所获点赞数。</li></ul><pre><code class="java">@Servicepublic class LikeService &#123;    @Autowired    private RedisTemplate redisTemplate;    // 点赞    public void like(int userId, int entityType, int entityId, int entityUserId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);                boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);                operations.multi();                if (isMember) &#123;                    operations.opsForSet().remove(entityLikeKey, userId);                    operations.opsForValue().decrement(userLikeKey);                &#125; else &#123;                    operations.opsForSet().add(entityLikeKey, userId);                    operations.opsForValue().increment(userLikeKey);                &#125;                return operations.exec();            &#125;        &#125;);    &#125;    // 查询某实体点赞的数量    public long findEntityLikeCount(int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().size(entityLikeKey);    &#125;    // 查询某人对某实体的点赞状态    public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;    &#125;    // 查询某个用户获得的赞    public int findUserLikeCount(int userId) &#123;        String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);        Integer count = (Integer) redisTemplate.opsForValue().get(userLikeKey);        return count == null ? 0 : count.intValue();    &#125;&#125;</code></pre><h2 id="更新表现层的-LikeController-类"><a href="#更新表现层的-LikeController-类" class="headerlink" title="更新表现层的 LikeController 类"></a>更新表现层的 LikeController 类</h2><ul><li>更新方法 <code>like()</code>：在参数列表中新增参数 entityUserId（表示被点赞用户的 id）。</li></ul><pre><code class="java">@Controllerpublic class LikeController &#123;    @Autowired    private LikeService likeService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/like&quot;)    @ResponseBody    public String like(int entityType, int entityId, int entityUserId) &#123;        User user = hostHolder.getUser();        // 点赞        likeService.like(user.getId(), entityType, entityId, entityUserId);        // 数量        long likeCount = likeService.findEntityLikeCount(entityType, entityId);        // 状态        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        // 返回的结果        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;, likeCount);        map.put(&quot;likeStatus&quot;, likeStatus);        return CommunityUtil.getJSONString(0, null, map);    &#125;&#125;</code></pre><h2 id="更新表现层的-UserController-类"><a href="#更新表现层的-UserController-类" class="headerlink" title="更新表现层的 UserController 类"></a>更新表现层的 UserController 类</h2><ul><li>新增方法<code>getProfilePage()</code>：调用业务层的方法查询用户和点赞数，并将两项信息存储于 Model 对象中。</li></ul><pre><code class="java">// 个人主页@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)public String getProfilePage(@PathVariable(&quot;userId&quot;) int userId, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot;该用户不存在!&quot;);    &#125;    // 用户    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    int likeCount = likeService.findUserLikeCount(userId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    return &quot;/site/profile&quot;;&#125;</code></pre><h1 id="3-关注"><a href="#3-关注" class="headerlink" title="3. 关注"></a>3. 关注</h1><h2 id="更新工具类-RedisUtil-1"><a href="#更新工具类-RedisUtil-1" class="headerlink" title="更新工具类 RedisUtil"></a>更新工具类 RedisUtil</h2><ul><li>新增用户关注实体（帖子、评论、用户等）的前缀常量 followee 和粉丝（用户）的前缀常量 follower。</li><li>新增方法 <code>getFolloweeKey(int userId, int entityType)</code>，通过用户 id 和实体类型生成用户关注实体的 key。</li><li>新增方法 <code>getFollowerKey(int entityType, int entityId)</code>，通过实体类型和实体 id 生成实体用户粉丝的 key。</li></ul><pre><code class="java">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    private static final String PREFIX_USER_LIKE = &quot;like:user&quot;;    private static final String PREFIX_FOLLOWEE = &quot;followee&quot;;    private static final String PREFIX_FOLLOWER = &quot;follower&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;    // 某个用户的赞    // like:user:userId -&gt; int    public static String getUserLikeKey(int userId) &#123;        return PREFIX_USER_LIKE + SPLIT + userId;    &#125;    // 某个用户关注的实体    // followee:userId:entityType -&gt; zset(entityId,now)    public static String getFolloweeKey(int userId, int entityType) &#123;        return PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;    &#125;    // 某个实体拥有的粉丝    // follower:entityType:entityId -&gt; zset(userId,now)    public static String getFollowerKey(int entityType, int entityId) &#123;        return PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;    &#125;&#125;</code></pre><h2 id="创建业务层的-FollowService-类"><a href="#创建业务层的-FollowService-类" class="headerlink" title="创建业务层的 FollowService 类"></a>创建业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>follow()</code>，当用户关注某实体时：</p><ul><li>调用方法 <code>add() </code>将当前实体 id 和时间作为 value 和 score 加入到用户的关注集合中。</li><li>调用方法 <code>add()</code> 将当前用户 id 和时间作为 value 和 score 加入到实体的粉丝集合中。</li></ul></li><li><p>新增方法 <code>unfollow()</code>，当用户取关某实体时：</p><ul><li>调用方法 <code>remove()</code> 将当前实体从用户的关注集合中移除。</li><li>调用方法 <code>remove()</code> 将用户从实体的粉丝集合中移除。</li></ul></li></ul><pre><code class="java">@Servicepublic class FollowService &#123;    @Autowired    private RedisTemplate redisTemplate;    public void follow(int userId, int entityType, int entityId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                operations.multi();                operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());                operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());                return operations.exec();            &#125;        &#125;);    &#125;    public void unfollow(int userId, int entityType, int entityId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                operations.multi();                operations.opsForZSet().remove(followeeKey, entityId);                operations.opsForZSet().remove(followerKey, userId);                return operations.exec();            &#125;        &#125;);    &#125;&#125;</code></pre><h2 id="创建表现层的-FollowController"><a href="#创建表现层的-FollowController" class="headerlink" title="创建表现层的 FollowController"></a>创建表现层的 FollowController</h2><ul><li>新增方法 <code>follow()</code>：调用 HostHolder 对象的方法获取用户，调用业务层的 <code>FollowService</code> 类的对象的方法 <code>follow()</code> 实现点赞的功能。</li><li>新增方法 <code>unfollow()</code>：调用 HostHolder 对象的方法获取用户，调用业务层的 <code>FollowService</code> 类的对象的方法 <code>unfollow()</code> 实现取消点赞的功能。</li></ul><pre><code class="java">@Controllerpublic class FollowController &#123;    @Autowired    private FollowService followService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/follow&quot;)    @ResponseBody    public String follow(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        followService.follow(user.getId(), entityType, entityId);        return CommunityUtil.getJSONString(0, &quot;已关注!&quot;);    &#125;    @PostMapping(&quot;/unfollow&quot;)    @ResponseBody    public String unfollow(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        followService.unfollow(user.getId(), entityType, entityId);        return CommunityUtil.getJSONString(0, &quot;已取消关注!&quot;);    &#125;&#125;</code></pre><h1 id="4-个人主页"><a href="#4-个人主页" class="headerlink" title="4. 个人主页"></a>4. 个人主页</h1><h2 id="更新业务层的-FollowService-类"><a href="#更新业务层的-FollowService-类" class="headerlink" title="更新业务层的 FollowService 类"></a>更新业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>findFolloweeCount()</code>，调用 zset 集合的方法<code>zcard()</code>查询某用户关注的实体数量。</p></li><li><p>新增方法 <code>findFollowerCount()</code>，调用 zset 集合的方法<code>zcard()</code>查询某实体的粉丝数量。</p></li><li><p>新增方法 <code>hasFollowed()</code>，根据 zset 集合的方法<code>zscore()</code>的返回值查询当前用户是否关注了某实体。</p></li></ul><pre><code class="java">// 查询关注的实体的数量public long findFolloweeCount(int userId, int entityType) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().zCard(followeeKey);&#125;// 查询实体的粉丝的数量public long findFollowerCount(int entityType, int entityId) &#123;    String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);    return redisTemplate.opsForZSet().zCard(followerKey);&#125;// 查询当前用户是否已关注该实体public boolean hasFollowed(int userId, int entityType, int entityId) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().score(followeeKey, entityId) != null;&#125;</code></pre><h2 id="更新表现层的-UserController-类-1"><a href="#更新表现层的-UserController-类-1" class="headerlink" title="更新表现层的 UserController 类"></a>更新表现层的 UserController 类</h2><ul><li><p>调用业务层的 <code>LikeService</code> 类中的方法 <code>findUserLikeCount()</code> 查询用户获赞数，并添加到 Model 中。</p></li><li><p>调用业务层的 <code>FollowService</code> 类中的方法 <code>findFolloweeCount()</code> 查询关注数量，调用方法 <code>findFollowerCount()</code> 查询粉丝数量，调用方法 <code>hasFollowed()</code> 查询用户是否关注，并将三项信息存储于 Model 对象中。</p></li><li><p>更新获取个人主页方法 <code>getProfilePage()</code>：新增关注数、粉丝数、判断是否已关注，并将三项信息存储于 Model 对象中。</p></li></ul><pre><code class="java">// 个人主页@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)public String getProfilePage(@PathVariable(&quot;userId&quot;) int userId, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot;该用户不存在!&quot;);    &#125;    // 用户    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    int likeCount = likeService.findUserLikeCount(userId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    // 关注数量    long followeeCount = followService.findFolloweeCount(userId, ENTITY_TYPE_USER);    model.addAttribute(&quot;followeeCount&quot;, followeeCount);    // 粉丝数量    long followerCount = followService.findFollowerCount(ENTITY_TYPE_USER, userId);    model.addAttribute(&quot;followerCount&quot;, followerCount);    // 是否已关注    boolean hasFollowed = false;    if (hostHolder.getUser() != null) &#123;        hasFollowed = followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);    &#125;    model.addAttribute(&quot;hasFollowed&quot;, hasFollowed);    return &quot;/site/profile&quot;;&#125;</code></pre><h1 id="5-关注列表和粉丝列表"><a href="#5-关注列表和粉丝列表" class="headerlink" title="5.关注列表和粉丝列表"></a>5.关注列表和粉丝列表</h1><h2 id="更新业务层的-FollowService-类-1"><a href="#更新业务层的-FollowService-类-1" class="headerlink" title="更新业务层的 FollowService 类"></a>更新业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>findFollowees()</code>：查询用户关注列表。通过 zset 集合的方法 <code>reverseRange()</code> 获取 value 即关注用户的 userId，再查询出其对应的 user，之后通过 score 获取关注时间，存入 map 集合中，将 map 添加到 list 列表中并返回。</p></li><li><p>新增方法 <code>findFollowers()</code>：查询用户粉丝列表。通过 zset 集合的方法 <code>reverseRange()</code> 获取 value 即粉丝的 userId，再查询出其对应的 user，之后通过 score 获取关注时间，存入 map 集合中，将 map 添加到 list 列表中并返回。</p></li><li><p>新增方法 <code>hasFollowed()</code>，根据 zset 集合的方法 <code>zscore()</code> 的返回值查询当前用户是否关注了某实体。</p></li></ul><pre><code class="java">// 查询某用户关注的人public List&lt;Map&lt;String, Object&gt;&gt; findFollowees(int userId, int offset, int limit) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - 1);    if (targetIds == null) &#123;        return null;    &#125;    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (Integer targetId : targetIds) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        User user = userService.findUserById(targetId);        map.put(&quot;user&quot;, user);        Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);        map.put(&quot;followTime&quot;, new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;// 查询某用户的粉丝public List&lt;Map&lt;String, Object&gt;&gt; findFollowers(int userId, int offset, int limit) &#123;    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - 1);    if (targetIds == null) &#123;        return null;    &#125;    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (Integer targetId : targetIds) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        User user = userService.findUserById(targetId);        map.put(&quot;user&quot;, user);        Double score = redisTemplate.opsForZSet().score(followerKey, targetId);        map.put(&quot;followTime&quot;, new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;</code></pre><h2 id="更新表现层的-FollowController-类"><a href="#更新表现层的-FollowController-类" class="headerlink" title="更新表现层的 FollowController 类"></a>更新表现层的 FollowController 类</h2><ul><li>新增方法 <code>getFollowees()</code>，获取关注列表，存入 Model 对象中。</li><li>新增方法 <code>getFollowers()</code>，获取粉丝列表，存入 Model 对象中。</li></ul><pre><code class="java">@GetMapping(&quot;/followees/&#123;userId&#125;&quot;)public String getFollowees(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot;该用户不存在!&quot;);    &#125;    model.addAttribute(&quot;user&quot;, user);    page.setLimit(5);    page.setPath(&quot;/followees/&quot; + userId);    page.setRows((int) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowees(userId, page.getOffset(), page.getLimit());    if (userList != null) &#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            User u = (User) map.get(&quot;user&quot;);            map.put(&quot;hasFollowed&quot;, hasFollowed(u.getId()));        &#125;    &#125;    model.addAttribute(&quot;users&quot;, userList);    return &quot;/site/followee&quot;;&#125;@GetMapping(&quot;/followers/&#123;userId&#125;&quot;)public String getFollowers(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot;该用户不存在!&quot;);    &#125;    model.addAttribute(&quot;user&quot;, user);    page.setLimit(5);    page.setPath(&quot;/followers/&quot; + userId);    page.setRows((int) followService.findFollowerCount(ENTITY_TYPE_USER, userId));    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowers(userId, page.getOffset(), page.getLimit());    if (userList != null) &#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            User u = (User) map.get(&quot;user&quot;);            map.put(&quot;hasFollowed&quot;, hasFollowed(u.getId()));        &#125;    &#125;    model.addAttribute(&quot;users&quot;, userList);    return &quot;/site/follower&quot;;&#125;private boolean hasFollowed(int userId) &#123;    if (hostHolder.getUser() == null) &#123;        return false;    &#125;    return followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);&#125;</code></pre><h1 id="6-优化登录模块"><a href="#6-优化登录模块" class="headerlink" title="6. 优化登录模块"></a>6. 优化登录模块</h1><ol><li><p>使用 Redis 存储验证码：验证码需要频繁访问与刷新，对性能要求较高；验证码不需要永久保存，通常在很短的时间内就会失效；分布式部署时，存在 Session 共享的问题。</p></li><li><p>使用 Redis 存储登录凭证：处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。</p></li><li><p>使用 Redis 缓存用户信息：每次处理请求时，都要根据凭证查询用户信息，访问的频率非常高。</p></li></ol><h2 id="6-1-存储验证码"><a href="#6-1-存储验证码" class="headerlink" title="6.1 存储验证码"></a>6.1 存储验证码</h2><ul><li>更新工具类 RedisUtil<ul><li>新增验证码前缀常量 <code>kaptcha</code></li><li>新增方法 <code>getKaptchaKey()</code>，通过用户凭证（由于未登录，采用 cookie 实现）获得对应验证码的 key（利用 String 存储验证码）。</li></ul></li></ul><pre><code class="java">private static final String PREFIX_KAPTCHA = &quot;kaptcha&quot;;// 登录验证码public static String getKaptchaKey(String owner) &#123;    return PREFIX_KAPTCHA + SPLIT + owner;&#125;</code></pre><ul><li>更新表现层的 LoginController 类<ul><li>重构方法 <code>getKaptcha()</code>，将验证码存入 redis，key 为当前随机生成的字符串，同时将该字符串存入 cookie。</li><li>重构方法 <code>login()</code>，从 cookie 中获取随机字符串，生成验证码的 key，然后获取 key 对应的 value 即验证码。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/kaptcha&quot;)public void getKaptcha(HttpServletResponse response/*, HttpSession session*/) &#123;    // 生成验证码    String text = kaptchaProducer.createText();    BufferedImage image = kaptchaProducer.createImage(text);    // 原来的做法：将验证码存入 session    // session.setAttribute(&quot;kaptcha&quot;, text);    // 验证码的归属    String kaptchaOwner = CommunityUtil.generateUUID();    Cookie cookie = new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);    cookie.setMaxAge(60);    cookie.setPath(contextPath);    response.addCookie(cookie);    // 将验证码存入Redis    String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);    redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);    // 将图片输出给浏览器    response.setContentType(&quot;image/png&quot;);    try &#123;        OutputStream os = response.getOutputStream();        ImageIO.write(image, &quot;png&quot;, os);    &#125; catch (IOException e) &#123;        logger.error(&quot;响应验证码失败:&quot; + e.getMessage());    &#125;&#125;@PostMapping(&quot;/login&quot;)public String login(String username, String password, String code, boolean rememberme,                    Model model, /*HttpSession session, */HttpServletResponse response,                    @CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner) &#123;    // 检查验证码    // String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);    String kaptcha = null;    if (StringUtils.isNotBlank(kaptchaOwner)) &#123;        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);        kaptcha = (String) redisTemplate.opsForValue().get(redisKey);    &#125;    if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123;        model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;);        return &quot;/site/login&quot;;    &#125;    // 检查账号,密码    int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);    if (map.containsKey(&quot;ticket&quot;)) &#123;        Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());        cookie.setPath(contextPath);        cookie.setMaxAge(expiredSeconds);        response.addCookie(cookie);        return &quot;redirect:/index&quot;;    &#125; else &#123;        model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;));        model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;));        return &quot;/site/login&quot;;    &#125;&#125;</code></pre><h2 id="6-2-存储登录凭证"><a href="#6-2-存储登录凭证" class="headerlink" title="6.2 存储登录凭证"></a>6.2 存储登录凭证</h2><ul><li>更新工具类 RedisUtil<ul><li>新增登录凭证前缀常量 <code>ticket</code></li><li>新增方法 <code>getTicketKey</code>() ，通过字符串获得登录凭证的对应 key （利用 String 存储）。</li></ul></li></ul><pre><code class="java">private static final String PREFIX_TICKET = &quot;ticket&quot;;// 登录的凭证public static String getTicketKey(String ticket) &#123;    return PREFIX_TICKET + SPLIT + ticket;&#125;</code></pre><ul><li><p>更新业务层的 UserService 类</p><ul><li><p>重构方法 <code>login()</code> ，将登录凭证存入 redis 中。</p></li><li><p>重构方法 <code>logout</code>() ，先从 redis 中获取登录凭证对象，将状态设为无效再重新存储进 redis。</p></li><li><p>重构方法 <code>findLoginTicket</code>() ，根据 ticket 字符串获得对应登录凭证的 key，然后从 redis 查询登录凭证。</p></li></ul></li></ul><pre><code class="java">public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) &#123;    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    // 空值处理    if (StringUtils.isBlank(username)) &#123;        map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;);        return map;    &#125;    if (StringUtils.isBlank(password)) &#123;        map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;);        return map;    &#125;    // 验证账号    User user = userMapper.selectByName(username);    if (user == null) &#123;        map.put(&quot;usernameMsg&quot;, &quot;该账号不存在!&quot;);        return map;    &#125;    // 验证状态    if (user.getStatus() == 0) &#123;        map.put(&quot;usernameMsg&quot;, &quot;该账号未激活!&quot;);        return map;    &#125;    // 验证密码    password = CommunityUtil.md5(password + user.getSalt());    if (!user.getPassword().equals(password)) &#123;        map.put(&quot;passwordMsg&quot;, &quot;密码不正确!&quot;);        return map;    &#125;    // 生成登录凭证    LoginTicket loginTicket = new LoginTicket();    loginTicket.setUserId(user.getId());    loginTicket.setTicket(CommunityUtil.generateUUID());    loginTicket.setStatus(0);    loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));        // loginTicketMapper.insertLoginTicket(loginTicket);    String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());    redisTemplate.opsForValue().set(redisKey, loginTicket);    map.put(&quot;ticket&quot;, loginTicket.getTicket());    return map;&#125;public void logout(String ticket) &#123;        // loginTicketMapper.updateStatus(ticket, 1);    String redisKey = RedisKeyUtil.getTicketKey(ticket);    LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);    loginTicket.setStatus(1);    redisTemplate.opsForValue().set(redisKey, loginTicket);&#125;public LoginTicket findLoginTicket(String ticket) &#123;        // return loginTicketMapper.selectByTicket(ticket);    String redisKey = RedisKeyUtil.getTicketKey(ticket);    return (LoginTicket) redisTemplate.opsForValue().get(redisKey);&#125;public int updateHeader(int userId, String headerUrl) &#123;        // return userMapper.updateHeader(userId, headerUrl);    int rows = userMapper.updateHeader(userId, headerUrl);    clearCache(userId);    return rows;&#125;</code></pre><h2 id="6-3-缓存用户信息"><a href="#6-3-缓存用户信息" class="headerlink" title="6.3 缓存用户信息"></a>6.3 缓存用户信息</h2><ul><li><p>更新工具类 RedisUtil </p><ul><li><p>新增用户前缀常量 <code>user</code></p></li><li><p>新增 <code>getUserKey</code> 方法，通过用户 id 获得用户的对应 key 值（利用 String 存储）。</p></li></ul></li></ul><pre><code class="java">private static final String PREFIX_USER = &quot;user&quot;;// 用户public static String getUserKey(int userId) &#123;    return PREFIX_USER + SPLIT + userId;&#125;</code></pre><ul><li><p>更新业务层的 UserService 类</p><ul><li><p>新增 <code>getCache</code>()，从缓存获取用户信息。</p></li><li><p>新增 <code>initCache()</code>，从 MySQL 查询用户信息并存入 redis。</p></li><li><p>新增 <code>clearCache()</code>，用户信息变更（更新头像，激活）时清除缓存。</p></li><li><p>重构 <code>findUserById()</code> 方法，首先调用 <code>getCache()</code>从缓存获取用户信息，如果获取为 null 则调用 <code>initCache()</code>。</p></li></ul></li></ul><pre><code class="java">// 1.优先从缓存中取值private User getCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    return (User) redisTemplate.opsForValue().get(redisKey);&#125;// 2.取不到时初始化缓存数据private User initCache(int userId) &#123;    User user = userMapper.selectById(userId);    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);    return user;&#125;// 3.数据变更时清除缓存数据private void clearCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.delete(redisKey);&#125;public User findUserById(int id) &#123;        // return userMapper.selectById(id);    User user = getCache(id);    if (user == null) &#123;        user = initCache(id);    &#125;    return user;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式流媒体平台 Kafka</title>
      <link href="/2023/03/07/kafka/"/>
      <url>/2023/03/07/kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h1><p>🌟 <a href="http://kafka.apach.org/">Kafka官网</a></p><ul><li>Kafka 是一个分布式的流媒体平台。</li><li>应用场景：消息系统、日志收集、用户行为追踪、流式处理。</li></ul><h1 id="Kafka-特点"><a href="#Kafka-特点" class="headerlink" title="Kafka 特点"></a>Kafka 特点</h1><ul><li>高吞吐量</li><li>消息持久化</li><li>高可靠性</li><li>高扩展性</li></ul><h1 id="Kafka-术语"><a href="#Kafka-术语" class="headerlink" title="Kafka 术语"></a>Kafka 术语</h1><ul><li>Broker</li><li>Zookeeper</li><li>Topic</li><li>Partition</li><li>Offset</li><li>Leader Replica</li><li>Follower Replica</li></ul><h1 id="Kafka-配置"><a href="#Kafka-配置" class="headerlink" title="Kafka 配置"></a>Kafka 配置</h1><ol><li>在 Kafka 安装包下的 config 文件夹下的 <code>zookeeper.properties</code>文件内修改：</li></ol><pre><code class="properties"># 默认存放路径dataDir=/tmp/zookeeper</code></pre><ol start="2"><li>在 Kafka 安装包下的 config 文件夹下的 <code>server.properties</code>文件内修改：</li></ol><pre><code class="properties"># 默认存放路径log.dirs=/tmp/kafka-logs</code></pre><h1 id="Kafka-常用命令"><a href="#Kafka-常用命令" class="headerlink" title="Kafka 常用命令"></a>Kafka 常用命令</h1><ol><li>打开一个 terminal 窗口，启动 Zookeeper：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ zookeeper-server-start.sh config\zookeeper.properties</code></pre><ol start="2"><li>打开另一个 terminal 窗口，启动 Kafka：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ zookeeper-server-start.sh config\server.properties</code></pre><ol start="3"><li>打开另一个 terminal 窗口，发布 topic 为 test，创建 1 个副本，创建 1 个分区：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test</code></pre><ol start="4"><li>查看是否成功发布 topic：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-topics.sh --list --bootstrap-server localhost:9092</code></pre><pre><code class="sh"># 发布 topic 成功，terminal 显示 testtest</code></pre><ol start="5"><li>生产者发布消息：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-console-producer.sh --broker-list localhost:9092 --topic test</code></pre><ol start="6"><li>消费者订阅消息：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre><h1 id="Windows-下关于-Kafka-的使用注意点"><a href="#Windows-下关于-Kafka-的使用注意点" class="headerlink" title="Windows 下关于 Kafka 的使用注意点"></a>Windows 下关于 Kafka 的使用注意点</h1><ul><li>问题：在 Windows 的命令行里启动 Kafka 之后，当关闭命令行窗口时，就会强制关闭 Kafka。这种关闭方式为暴力关闭，很可能会导致 Kafka 无法完成对日志文件的解锁。届时，再次启动 Kafka 的时候，就会提示日志文件被锁，无法成功启动。</li><li>方案：将 Kafka 的日志文件全部删除，再次启动即可。</li><li>建议：不要暴力关闭 Kafka，建议通过在命令行执行 <code>kafka-server-stop</code> 命令来关闭它。</li><li>其他：将来在 Linux 上部署 Kafka 之后，采用后台运行的方式，就会避免这样的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to My HomePage!</title>
      <link href="/2023/03/05/hello-world/"/>
      <url>/2023/03/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MacOS下安装Node.js避坑指南</title>
      <link href="/2023/03/05/macos_nodejs/"/>
      <url>/2023/03/05/macos_nodejs/</url>
      
        <content type="html"><![CDATA[<ul><li><p>不建议的方法：直接到 Node 官网下载<code>.pkg</code>文件进行安装。</p></li><li><p>可能出现的问题：使用<code>npm install -g hexo-cli</code>等指令会报错没有写入的权限，甚至尝试各种<code>sudo</code>权限都无效。</p></li><li><p>npm 官网教程也不推荐采用<code>installer</code>进行安装。</p></li></ul><h2 id="安装Node-js和npm的正确方法"><a href="#安装Node-js和npm的正确方法" class="headerlink" title="安装Node.js和npm的正确方法"></a>安装Node.js和npm的正确方法</h2><p>🌟 使用 node 版本管理工<code>nvm</code>(node version manager)安装 Node.js 和 npm。</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>安装<code>nvm</code>：</p><pre><code>~$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</code></pre><p>验证<code>nvm</code>是否安装成功：</p><pre><code>~$ command -v nvm</code></pre><p>若成功则出现一行<code>nvm</code>字符(若未出现则重启<code>terminal</code>)，查询<code>nvm</code>版本：</p><pre><code>~$ nvm --version</code></pre><p>返回<code>nvm</code>版本号：<code>0.34.0</code></p><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>使用<code>nvm</code>安装<code>node</code>：</p><pre><code>~$ nvm install node # &quot;node&quot; is an alias for the latest version</code></pre><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>使用<code>npm</code>指令安装<code>hexo</code>：</p><pre><code>~$ npm install -g hexo-cli</code></pre><p>初始化<code>hexo</code>，指定文件夹名为 blog：</p><pre><code>~$ hexo init blog</code></pre><p>进入 blog 文件夹下，安装<code>npm</code>：</p><pre><code>~ $ cd blog~ $ npm istall</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>Q1：<code>zsh: command not found: nvm</code></p><p>A1：进入 .nvm 文件夹，查看是否存在 .bash_profile 文件，若存在该文件则直接打开：</p><pre><code>cd ~/.nvmopen .bash_profile</code></pre><p>若不存在则先创建 .bash_profile 文件：</p><pre><code>touch .bash_profile</code></pre><p>然后在 .bash_profile 文件内写入：</p><pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</code></pre><p>写入完毕后，关闭文件，执行 .bash_profile 文件：</p><pre><code>source .bash_profile</code></pre><p>Q2：每次关闭<code>terminal</code>后，又出现<code>zsh: command not found: nvm</code>等无法找到某指令的情况，需要重新执行 .bash_profile 文件。</p><p>A2：原因是采用的<code>terminal</code>是<code>zsh</code>，需要将配置添加到 .zshrc 文件中。</p><p>打开  .zshrc 文件：</p><pre><code>open ~/.zshrc</code></pre><p>在 .zshrc 文件内写入：</p><pre><code>export NVM_DIR=~/.nvm[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;</code></pre><p>写入完毕后，关闭文件，执行 .zshrc 文件：</p><pre><code>source ~/.zshrc</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode算法笔记之链表(双指针解法)</title>
      <link href="/2023/03/01/linkedlist/"/>
      <url>/2023/03/01/linkedlist/</url>
      
        <content type="html"><![CDATA[<p>🌟 LeetCode算法笔记之链表，复习整理双指针解决链表题目。</p><h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle/">题源：141. Linked List Cycle</a></p><p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置双指针，慢指针 slow 每次前进一步，快指针 fast 每次前进两步。</li><li>如果 fast 最终遇到空指针，说明链表中没有环.</li><li>如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        ListNode fast = head, slow = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;            if (fast == slow) return true;        &#125;        return false;    &#125;&#125;</code></pre><h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">题源：142. Linked List Cycle II</a></p><p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ul><li><p>设置双指针，慢指针 slow 每次前进一步，快指针 fast 每次前进两步。</p></li><li><p>当快、慢指针相遇时：</p><ul><li>让其中一个指针指向头节点；</li><li>此时，设置快、慢指针前进速度一致，均每次前进一步。</li></ul></li><li><p>原理：当快、慢指针分别以 2v、v 的速度前进并第一次相遇时：</p><ul><li>如果慢指针走了 k 步，则快指针一定走了 2k 步。</li><li>快指针比慢指针多走的 k 步，其实就是快指针在环内转圈，即 k 值为环长度的 <em>整数倍</em>。</li><li>假设相遇点 M 距离环的起点 C 的距离为 m，则慢指针从头节点 H 到环的起点 C 的移动距离HC 为 <code>k - m</code>。</li><li>也就是说如果快、慢指针在相遇点 M 时，重置慢指针，让慢指针再次从头节点 H 出发，前进 <code>k - m</code> 步即可到达环的起点 C。</li><li>此时，如果快指针从相遇点继续前进，且速度和慢指针保持一致都为 v，恰巧也需前进 <code>k - m</code> 步即可到达环的起点 C。</li></ul></li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        ListNode fast = head, slow = head;          // 第一个 while 循环是为了寻找相遇点 M        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;            if (slow == fast) break;        &#125;        if (fast == null || fast.next == null) return null;        slow = head;          // 第二个 while 循环是为了重置慢指针到头节点并寻找两个指针最终的目的地即 环起点        while (slow != fast) &#123;            fast = fast.next;            slow = slow.next;        &#125;        return slow;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
