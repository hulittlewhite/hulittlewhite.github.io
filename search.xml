<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>校园社区论坛项目之 Spring Security</title>
      <link href="/2023/03/08/community7/"/>
      <url>/2023/03/08/community7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-Security"><a href="#1-Spring-Security" class="headerlink" title="1. Spring Security"></a>1. Spring Security</h1><ul><li> 简介 ：<ul><li>Spring Security 是一个专注于为 Java 应用程序提供身份认证和授权的框架，其强大之处在于可以轻松扩展以满足自定义需求。</li></ul></li><li> 特征：<ul><li> 对身份的认证、授权提供全面的、可扩展的支持。</li><li> 防止各种攻击，如会话固定攻击、点击劫持、CSRF 攻击等。</li><li> 支持与 Servlet API、Spring MVC 等 Web 技术集成。</li></ul></li></ul><h1 id="2- 权限控制"><a href="#2- 权限控制" class="headerlink" title="2. 权限控制"></a>2. 权限控制 </h1><ul><li> 登录检查：<ul><li> 弃用原先采用的拦截器检查用户登录 (过于简单)。</li></ul></li><li> 授权配置：<ul><li> 对当前系统内包含的所有的请求，分配访问权限（普通用户、版主、管理员）。</li></ul></li><li> 认证方案：<ul><li> 绕过 Security 认证流程，采用系统原来的认证方案。</li></ul></li><li>CSRF 配置：<ul><li> 防止 CSRF 攻击的基本原理，以及表单、AJAX 相关的配置。</li></ul></li></ul><h1 id="3- 置顶、加精、删除"><a href="#3- 置顶、加精、删除" class="headerlink" title="3. 置顶、加精、删除"></a>3. 置顶、加精、删除 </h1><ul><li> 功能实现 <ul><li> 点击按钮“置顶”，修改帖子的类型。</li><li> 点击按钮“加精”、“删除”，修改帖子的状态。</li></ul></li><li> 权限管理 <ul><li> 版主可以执行“置顶”、“加精”操作。</li><li> 管理员可以执行“删除”操作。</li></ul></li><li> 按钮显示 <ul><li> 版主可以看到“置顶”、“加精”按钮。</li><li> 管理员可以看到“删除”按钮。</li></ul></li></ul><h1 id="4-Redis- 高级数据类型"><a href="#4-Redis- 高级数据类型" class="headerlink" title="4. Redis 高级数据类型"></a>4. Redis 高级数据类型 </h1><ul><li>HyperLogLog<ul><li> 采用一种基数算法，用于完成独立总数的统计。</li><li> 占据空间小，无论统计多少个数据，只占 12K 的内存空间。</li><li> 不精确的统计算法，标准误差为 0.81% 。</li></ul></li><li>Bitmap<ul><li> 不是一种独立的数据结构，实际上就是字符串。</li><li> 支持按位存取数据，可以将其看成是 byte 数组。</li><li> 适合存储索大量的连续的数据的布尔值。</li></ul></li></ul><h1 id="5- 网站数据统计"><a href="#5- 网站数据统计" class="headerlink" title="5. 网站数据统计"></a>5. 网站数据统计 </h1><ul><li>UV（Unique Visitor） <ul><li> 独立访客，需通过用户 IP 排重统计数据。 </li><li> 每次访问都要进行统计。 </li><li>HyperLogLog ，性能好，且存储空间小。</li></ul></li><li>DAU（Daily Active User） </li><li> 日活跃用户，需通过用户 ID 排重统计数据。 </li><li> 访问过一次，则认为其活跃。 </li><li>Bitmap，性能好、且可以统计精确的结果。</li></ul><h1 id="6- 任务执行和调度"><a href="#6- 任务执行和调度" class="headerlink" title="6. 任务执行和调度"></a>6. 任务执行和调度 </h1><ul><li>JDK 线程池 <ul><li>ExcecutorService </li><li>ScheduledExecutorService</li></ul></li><li>Spring 线程池 <ul><li>ThreadPoolTaskExecutor </li><li>ThreadPoolTaskScheduler</li></ul></li><li> 分布式定时任务 <ul><li>Spring Quartz</li></ul></li></ul><h1 id="7- 热帖排行"><a href="#7- 热帖排行" class="headerlink" title="7. 热帖排行"></a>7. 热帖排行 </h1><ul><li>Hacker News <ul><li>Score &#x3D; (P-1) &#x2F; (T+2) ^ G</li></ul></li><li>StackOverflow <ul><li>(log(Qviews)*4) + ((Qanswers * Qscore)&#x2F;5) + sum(Ascores)</li><li>((QageInHours + 1) - ((QageInHours - Qupdated)&#x2F;2)) ^ 1.5</li></ul></li><li>School<ul><li>log(精华分 + 评论数 * 10 + 点赞数 * 2 + 收藏数 * 2) + (发布时间 – School 纪元)</li></ul></li></ul><h1 id="8- 生成长图"><a href="#8- 生成长图" class="headerlink" title="8. 生成长图"></a>8. 生成长图 </h1><ul><li><p>wkhtmltopdf </p><ul><li>wkhtmltopdf url file </li><li>wkhtmltoimage url file</li></ul></li><li><p>java </p><ul><li>Runtime.getRuntime().exec()</li></ul></li></ul><h1 id="9- 将文件上传至云服务器"><a href="#9- 将文件上传至云服务器" class="headerlink" title="9. 将文件上传至云服务器"></a>9. 将文件上传至云服务器 </h1><ul><li> 客户端上传 <ul><li> 客户端将数据提交给云服务器，并等待其响应。 </li><li> 用户上传头像时，将表单数据提交给云服务器。</li></ul></li><li> 服务器直传 <ul><li> 应用服务器将数据直接提交给云服务器，并等待其响应。 </li><li> 分享时，服务端将自动生成的图片，直接提交给云服务器。</li></ul></li></ul><h1 id="10- 优化网站的性能"><a href="#10- 优化网站的性能" class="headerlink" title="10. 优化网站的性能"></a>10. 优化网站的性能 </h1><ul><li> 本地缓存 <ul><li> 将数据缓存在应用服务器上，性能最好。 </li><li> 常用缓存工具：Ehcache、Guava、Caffeine 等。</li></ul></li><li> 分布式缓存 <ul><li> 将数据缓存在 NoSQL 数据库上，跨服务器。 </li><li> 常用缓存工具：MemCache、Redis 等。</li></ul></li><li> 多级缓存 <ul><li> 一级缓存（本地缓存）&#x3D;&#x3D;&gt; 二级缓存（分布式缓存）&#x3D;&#x3D;&gt; DB </li><li> 避免缓存雪崩（缓存失效，大量请求直达 DB ），提高系统的可用性。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Elasticsearch</title>
      <link href="/2023/03/08/community6/"/>
      <url>/2023/03/08/community6/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Elasticsearch 实现校园社区论坛项目的搜索功能。</p><p>🌟 准备工作：</p><ol><li> 引入 Elasticsearch 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li> 在 application.properties 文件中配置 Elasticsearch 的集群名和节点：</li></ol><pre><code class="properties"># ElasticsearchPropertiesspring.data.elasticsearch.cluster-name=nowcoderspring.data.elasticsearch.cluster-nodes=127.0.0.1:9300</code></pre><ol start="3"><li> 在 CommunityApplication.java 文件中新增方法 <code>init()</code> ：解决 netty 启动冲突。</li></ol><pre><code class="java">@SpringBootApplicationpublic class CommunityApplication &#123;    @PostConstruct    public void init() &#123;        // 解决 netty 启动冲突问题        // see Netty4Utils.setAvailableProcessors()        System.setProperty(&quot;es.set.netty.runtime.available.processors&quot;, &quot;false&quot;);    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(CommunityApplication.class, args);    &#125;&#125;</code></pre><h1 id="1- 建立实体类属性到 -ES- 索引的映射"><a href="#1- 建立实体类属性到 -ES- 索引的映射" class="headerlink" title="1. 建立实体类属性到 ES 索引的映射"></a>1. 建立实体类属性到 ES 索引的映射 </h1><ul><li> 在实体类 DiscussPost 上新增注解 <code>@Document</code></li><li> 将实体类 DiscussPost 的属性与 Elasticsearch 索引建立映射关系。</li></ul><pre><code class="java">@Document(indexName = &quot;discusspost&quot;, type = &quot;_doc&quot;, shards = 6, replicas = 3)public class DiscussPost &#123;    @Id    private int id;    @Field(type = FieldType.Integer)    private int userId;    // 互联网校招    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)    private String title;    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)    private String content;    @Field(type = FieldType.Integer)    private int type;    @Field(type = FieldType.Integer)    private int status;    @Field(type = FieldType.Date)    private Date createTime;    @Field(type = FieldType.Integer)    private int commentCount;    @Field(type = FieldType.Double)    private double score;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public void setUserId(int userId) &#123;        this.userId = userId;    &#125;    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;    public int getType() &#123;        return type;    &#125;    public void setType(int type) &#123;        this.type = type;    &#125;    public int getStatus() &#123;        return status;    &#125;    public void setStatus(int status) &#123;        this.status = status;    &#125;    public Date getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Date createTime) &#123;        this.createTime = createTime;    &#125;    public int getCommentCount() &#123;        return commentCount;    &#125;    public void setCommentCount(int commentCount) &#123;        this.commentCount = commentCount;    &#125;    public double getScore() &#123;        return score;    &#125;    public void setScore(double score) &#123;        this.score = score;    &#125;    @Override    public String toString() &#123;        return &quot;DiscussPost&#123;&quot; +                &quot;id=&quot; + id +                &quot;, userId=&quot; + userId +                &quot;, title=&#39;&quot; + title + &#39;\&#39;&#39; +                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +                &quot;, type=&quot; + type +                &quot;, status=&quot; + status +                &quot;, createTime=&quot; + createTime +                &quot;, commentCount=&quot; + commentCount +                &quot;, score=&quot; + score +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h1 id="2- 创建数据访问层的接口"><a href="#2- 创建数据访问层的接口" class="headerlink" title="2. 创建数据访问层的接口"></a>2. 创建数据访问层的接口 </h1><ul><li> 创建数据访问层的接口 DiscussPostRepository，该接口继承接口 ElasticsearchRepository</li></ul><pre><code class="java">@Repositorypublic interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost, Integer&gt; &#123;&#125;</code></pre><h1 id="3- 访问 -Elasticsearch- 服务器"><a href="#3- 访问 -Elasticsearch- 服务器" class="headerlink" title="3. 访问 Elasticsearch 服务器"></a>3. 访问 Elasticsearch 服务器 </h1><ul><li> 使用 Spring 整合 Elasticsearch，并编写测试代码访问 Elasticsearch 服务器。</li></ul><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = CommunityApplication.class)public class ElasticsearchTests &#123;    @Autowired    private DiscussPostMapper discussMapper;    @Autowired    private DiscussPostRepository discussRepository;    @Autowired    private ElasticsearchTemplate elasticTemplate;    @Test    public void testInsert() &#123;        discussRepository.save(discussMapper.selectDiscussPostById(241));        discussRepository.save(discussMapper.selectDiscussPostById(242));        discussRepository.save(discussMapper.selectDiscussPostById(243));    &#125;    @Test    public void testInsertList() &#123;        discussRepository.saveAll(discussMapper.selectDiscussPosts(101, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(102, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(103, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(111, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(112, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(131, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(132, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(133, 0, 100));        discussRepository.saveAll(discussMapper.selectDiscussPosts(134, 0, 100));    &#125;    @Test    public void testUpdate() &#123;        DiscussPost post = discussMapper.selectDiscussPostById(231);        post.setContent(&quot;This is some contents.&quot;);        discussRepository.save(post);    &#125;    @Test    public void testDelete() &#123;        // discussRepository.deleteById(231);        discussRepository.deleteAll();    &#125;    @Test    public void testSearchByRepository() &#123;        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(&quot;xx 关键词 &quot;, &quot;title&quot;, &quot;content&quot;))                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .withPageable(PageRequest.of(0, 10))                .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)                ).build();        // elasticTemplate.queryForPage(searchQuery, class, SearchResultMapper)        // 底层获取得到了高亮显示的值, 但是没有返回.        Page&lt;DiscussPost&gt; page = discussRepository.search(searchQuery);        System.out.println(page.getTotalElements());        System.out.println(page.getTotalPages());        System.out.println(page.getNumber());        System.out.println(page.getSize());        for (DiscussPost post : page) &#123;            System.out.println(post);        &#125;    &#125;    @Test    public void testSearchByTemplate() &#123;        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(&quot;xx 关键词 &quot;, &quot;title&quot;, &quot;content&quot;))                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .withPageable(PageRequest.of(0, 10))                .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)                ).build();        Page&lt;DiscussPost&gt; page = elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() &#123;            @Override            public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable) &#123;                SearchHits hits = response.getHits();                if (hits.getTotalHits() &lt;= 0) &#123;                    return null;                &#125;                List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();                for (SearchHit hit : hits) &#123;                    DiscussPost post = new DiscussPost();                    String id = hit.getSourceAsMap().get(&quot;id&quot;).toString();                    post.setId(Integer.valueOf(id));                    String userId = hit.getSourceAsMap().get(&quot;userId&quot;).toString();                    post.setUserId(Integer.valueOf(userId));                    String title = hit.getSourceAsMap().get(&quot;title&quot;).toString();                    post.setTitle(title);                    String content = hit.getSourceAsMap().get(&quot;content&quot;).toString();                    post.setContent(content);                    String status = hit.getSourceAsMap().get(&quot;status&quot;).toString();                    post.setStatus(Integer.valueOf(status));                    String createTime = hit.getSourceAsMap().get(&quot;createTime&quot;).toString();                    post.setCreateTime(new Date(Long.valueOf(createTime)));                    String commentCount = hit.getSourceAsMap().get(&quot;commentCount&quot;).toString();                    post.setCommentCount(Integer.valueOf(commentCount));                    // 处理高亮显示的结果                    HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);                    if (titleField != null) &#123;                        post.setTitle(titleField.getFragments()[0].toString());                    &#125;                    HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);                    if (contentField != null) &#123;                        post.setContent(contentField.getFragments()[0].toString());                    &#125;                    list.add(post);                &#125;                return new AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            &#125;        &#125;);        System.out.println(page.getTotalElements());        System.out.println(page.getTotalPages());        System.out.println(page.getNumber());        System.out.println(page.getSize());        for (DiscussPost post : page) &#123;            System.out.println(post);        &#125;    &#125;&#125;</code></pre><h1 id="4- 开发社区搜索功能"><a href="#4- 开发社区搜索功能" class="headerlink" title="4. 开发社区搜索功能"></a>4. 开发社区搜索功能 </h1><ol><li> 搜索服务：将帖子保存至 Elasticsearch 服务器；从 Elasticsearch 服务器中删除 &#x2F; 搜索帖子。</li><li> 发布事件：发布帖子时，将帖子以异步的方式提交到 Elasticsearch 服务器；增加帖子时，将帖子以异步的方式提交到 Elasticsearch 服务器；在消费组件中新增方法：消费帖子发布事件。</li><li> 显示结果：在 Controller 中处理搜索请求，并在 HTML 页面显示搜索结果。</li></ol><h2 id="4-1- 搜索服务"><a href="#4-1- 搜索服务" class="headerlink" title="4.1 搜索服务"></a>4.1 搜索服务 </h2><ul><li> 创建业务层的 ElasticsearchService 类：<ul><li> 注入 DiscussPostRepository 实例和 ElasticsearchTemplate 示例。</li><li> 新增方法 <code>saveDiscussPost()</code>：保存帖子到 Elasticsearch 服务器。</li><li> 新增方法 <code>deleteDiscussPost()</code>：删除 Elasticsearch 服务器中的帖子。</li><li> 新增方法 <code>searchDiscussPost()</code>：搜索 Elasticsearch 服务器中的帖子。</li></ul></li></ul><pre><code class="java">@Servicepublic class ElasticsearchService &#123;    @Autowired    private DiscussPostRepository discussRepository;    @Autowired    private ElasticsearchTemplate elasticTemplate;    public void saveDiscussPost(DiscussPost post) &#123;        discussRepository.save(post);    &#125;    public void deleteDiscussPost(int id) &#123;        discussRepository.deleteById(id);    &#125;    public Page&lt;DiscussPost&gt; searchDiscussPost(String keyword, int current, int limit) &#123;        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(keyword, &quot;title&quot;, &quot;content&quot;))                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .withPageable(PageRequest.of(current, limit))                .withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)                ).build();        return elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() &#123;            @Override            public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable) &#123;                SearchHits hits = response.getHits();                if (hits.getTotalHits() &lt;= 0) &#123;                    return null;                &#125;                List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();                for (SearchHit hit : hits) &#123;                    DiscussPost post = new DiscussPost();                    String id = hit.getSourceAsMap().get(&quot;id&quot;).toString();                    post.setId(Integer.valueOf(id));                    String userId = hit.getSourceAsMap().get(&quot;userId&quot;).toString();                    post.setUserId(Integer.valueOf(userId));                    String title = hit.getSourceAsMap().get(&quot;title&quot;).toString();                    post.setTitle(title);                    String content = hit.getSourceAsMap().get(&quot;content&quot;).toString();                    post.setContent(content);                    String status = hit.getSourceAsMap().get(&quot;status&quot;).toString();                    post.setStatus(Integer.valueOf(status));                    String createTime = hit.getSourceAsMap().get(&quot;createTime&quot;).toString();                    post.setCreateTime(new Date(Long.valueOf(createTime)));                    String commentCount = hit.getSourceAsMap().get(&quot;commentCount&quot;).toString();                    post.setCommentCount(Integer.valueOf(commentCount));                    // 处理高亮显示的结果                    HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);                    if (titleField != null) &#123;                        post.setTitle(titleField.getFragments()[0].toString());                    &#125;                    HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);                    if (contentField != null) &#123;                        post.setContent(contentField.getFragments()[0].toString());                    &#125;                    list.add(post);                &#125;                return new AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            &#125;        &#125;);    &#125;&#125;</code></pre><h2 id="4-2- 发布事件"><a href="#4-2- 发布事件" class="headerlink" title="4.2 发布事件"></a>4.2 发布事件 </h2><ul><li> 更新表现层的 DiscussPostController 类：<ul><li> 更新方法 <code>addDiscussPost()</code>：新增触发发帖事件。</li></ul></li></ul><pre><code class="java">@PostMapping(&quot;/add&quot;)@ResponseBodypublic String addDiscussPost(String title, String content) &#123;    User user = hostHolder.getUser();    if (user == null) &#123;        return CommunityUtil.getJSONString(403, &quot; 你还没有登录哦!&quot;);    &#125;    DiscussPost post = new DiscussPost();    post.setUserId(user.getId());    post.setTitle(title);    post.setContent(content);    post.setCreateTime(new Date());    discussPostService.addDiscussPost(post);    // 触发发帖事件    Event event = new Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(user.getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(post.getId());    eventProducer.fireEvent(event);    // 报错的情况, 将来统一处理.    return CommunityUtil.getJSONString(0, &quot; 发布成功!&quot;);&#125;</code></pre><ul><li> 更新表现层的 CommentController 类：<ul><li> 更新方法 <code>addComment()</code>：新增触发发帖事件。</li></ul></li></ul><pre><code class="java">@PostMapping(&quot;/add/&#123;discussPostId&#125;&quot;)public String addComment(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Comment comment) &#123;    comment.setUserId(hostHolder.getUser().getId());    comment.setStatus(0);    comment.setCreateTime(new Date());    commentService.addComment(comment);    // 触发评论事件    Event event = new Event()            .setTopic(TOPIC_COMMENT)            .setUserId(hostHolder.getUser().getId())            .setEntityType(comment.getEntityType())            .setEntityId(comment.getEntityId())            .setData(&quot;postId&quot;, discussPostId);    if (comment.getEntityType() == ENTITY_TYPE_POST) &#123;        DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125; else if (comment.getEntityType() == ENTITY_TYPE_COMMENT) &#123;        Comment target = commentService.findCommentById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125;    eventProducer.fireEvent(event);    if (comment.getEntityType() == ENTITY_TYPE_POST) &#123;        // 触发发帖事件        event = new Event()                .setTopic(TOPIC_PUBLISH)                .setUserId(comment.getUserId())                .setEntityType(ENTITY_TYPE_POST)                .setEntityId(discussPostId);        eventProducer.fireEvent(event);    &#125;    return &quot;redirect:/discuss/detail/&quot; + discussPostId;&#125;</code></pre><h2 id="4-3- 消费事件"><a href="#4-3- 消费事件" class="headerlink" title="4.3 消费事件"></a>4.3 消费事件 </h2><ul><li> 更新消费组件 EventConsumer 类：<ul><li> 新增方法 <code>handlePublishMessage()</code>：消费帖子发布事件。</li></ul></li></ul><pre><code class="java">// 消费发帖事件@KafkaListener(topics = &#123;TOPIC_PUBLISH&#125;)public void handlePublishMessage(ConsumerRecord record) &#123;    if (record == null || record.value() == null) &#123;        logger.error(&quot; 消息的内容为空!&quot;);        return;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    if (event == null) &#123;        logger.error(&quot; 消息格式错误!&quot;);        return;    &#125;    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());    elasticsearchService.saveDiscussPost(post);&#125;</code></pre><h2 id="4-4- 显示搜索结果"><a href="#4-4- 显示搜索结果" class="headerlink" title="4.4 显示搜索结果"></a>4.4 显示搜索结果 </h2><ul><li> 创建表现层的 SearchController 类：<ul><li> 注入 ElasticsearchService 实例、UserService 实例、LikeService 实例。</li><li> 新增方法 <code>search()</code>：实现帖子搜索 (聚合数据、分页信息) 功能。</li></ul></li></ul><pre><code class="java">@Controllerpublic class SearchController implements CommunityConstant &#123;    @Autowired    private ElasticsearchService elasticsearchService;    @Autowired    private UserService userService;    @Autowired    private LikeService likeService;    // search?keyword=xxx    @RequestMapping(path = &quot;/search&quot;, method = RequestMethod.GET)    public String search(String keyword, Page page, Model model) &#123;        // 搜索帖子        org.springframework.data.domain.Page&lt;DiscussPost&gt; searchResult =                elasticsearchService.searchDiscussPost(keyword, page.getCurrent() - 1, page.getLimit());        // 聚合数据        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;();        if (searchResult != null) &#123;            for (DiscussPost post : searchResult) &#123;                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                // 帖子                map.put(&quot;post&quot;, post);                // 作者                map.put(&quot;user&quot;, userService.findUserById(post.getUserId()));                // 点赞数量                map.put(&quot;likeCount&quot;, likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId()));                discussPosts.add(map);            &#125;        &#125;        model.addAttribute(&quot;discussPosts&quot;, discussPosts);        model.addAttribute(&quot;keyword&quot;, keyword);        // 分页信息        page.setPath(&quot;/search?keyword=&quot; + keyword);        page.setRows(searchResult == null ? 0 : (int) searchResult.getTotalElements());        return &quot;/site/search&quot;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式搜索引擎 Elasticsearch</title>
      <link href="/2023/03/07/Elasticsearch/"/>
      <url>/2023/03/07/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch 简介"><a href="#Elasticsearch 简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介 </h1><ul><li> 一个分布式的、Restful 风格的搜索引擎。 </li><li> 支持对各种类型的数据的检索。 </li><li> 搜索速度快，可以提供实时的搜索服务。 </li><li> 便于水平扩展，每秒可以处理 PB 级海量数据。 </li><li>Elasticsearch 术语 <ul><li> 索引、类型、文档、字段 </li><li> 集群、节点、分片、副本。</li></ul></li></ul><h1 id="Elasticsearch- 配置"><a href="#Elasticsearch- 配置" class="headerlink" title="Elasticsearch 配置"></a>Elasticsearch 配置 </h1><ol><li> 在 Elasticsearch 安装包下的 config 文件夹下的 <code>slasticsearch.yml</code> 文件内修改：</li></ol><pre><code class="yaml"># 集群名cluster.name = my-application# 数据存储路径path.data: /path/to/data# 日志存放路径path.logs: /path/to/logs</code></pre><ol start="2"><li>ES 默认申请 1G 内存，可在 Elasticsearch 安装包下的 config 文件夹下的 <code>jvm.options</code> 文件内修改：</li></ol><pre><code class="properties"># 初始内存-Xms256m# 最大内存-Xmx512m</code></pre><ol start="3"><li> 安装分词插件 <a href="https://github.com/medcl/elasticsearch-analysis-ik">elasticsearch-analysis-ik</a>，将其放到 Elasticsearch 安装包下的 plugins 文件夹下的 ik 文件夹下。在 IKAnalyzer.cfg.xml 文件内可以配置自定义词，在同级目录下新建 <code>.dic</code> 文件即可。</li></ol><table><thead><tr><th align="center">IK version</th><th align="center">ES version</th></tr></thead><tbody><tr><td align="center">master</td><td align="center">7.x -&gt; master</td></tr><tr><td align="center">6.x</td><td align="center">6.x</td></tr><tr><td align="center">5.x</td><td align="center">5.x</td></tr><tr><td align="center">1.10.6</td><td align="center">2.4.6</td></tr><tr><td align="center">1.9.5</td><td align="center">2.3.5</td></tr><tr><td align="center">1.8.1</td><td align="center">2.2.1</td></tr><tr><td align="center">1.7.0</td><td align="center">2.1.1</td></tr><tr><td align="center">1.5.0</td><td align="center">2.0.0</td></tr><tr><td align="center">1.2.6</td><td align="center">1.0.0</td></tr><tr><td align="center">1.2.5</td><td align="center">0.90.x</td></tr><tr><td align="center">1.1.3</td><td align="center">0.20.x</td></tr><tr><td align="center">1.0.0</td><td align="center">0.16.2 -&gt; 0.19.0</td></tr></tbody></table><ol start="4"><li> 安装 <a href="https://www.postman.com/">Postman</a>，可通过其访问 Elasticsearch 服务器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Kafka</title>
      <link href="/2023/03/07/community5/"/>
      <url>/2023/03/07/community5/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Kafka 实现校园社区论坛项目的发送系统通知、显示系统通知的功能。</p><p>🌟 准备工作：</p><ol><li>引入 Kafka 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;        &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在 application.properties 文件中配置 Kafka 的 server 和 consumer：</li></ol><pre><code class="properties"># KafkaPropertiesspring.kafka.bootstrap-servers=localhost:9092spring.kafka.consumer.group-id=community-consumer-groupspring.kafka.consumer.enable-auto-commit=truespring.kafka.consumer.auto-commit-interval=3000</code></pre><ol start="3"><li>访问 Kafka：</li></ol><p>生产者</p><pre><code>kafkaTemplate.send(topic, data);</code></pre><p>消费者</p><pre><code>@KafkaListener(topic = &#123;&quot;test&quot;&#125;)</code></pre><pre><code>public void handleMessage(ConsumerRecord record)&#123;&#125;</code></pre><h1 id="1- 发送系统通知"><a href="#1- 发送系统通知" class="headerlink" title="1. 发送系统通知"></a>1. 发送系统通知</h1><ol><li>触发事件：评论后发布通知；点赞后发布通知；关注后发布通知。</li><li>处理事件：封装事件对象；开发事件的生产者；开发事件的消费者。</li></ol><h2 id="创建实体类 -Event"><a href="# 创建实体类 -Event" class="headerlink" title="创建实体类 Event"></a>创建实体类 Event</h2><ul><li>封装事件对象，包括主题、用户 id、实体类型、实体 id、实体用户 id 以及一个 map 集合存放其它信息。</li></ul><pre><code class="java">public class Event &#123;    private String topic;    private int userId;    private int entityType;    private int entityId;    private int entityUserId;    private Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();    public String getTopic() &#123;        return topic;    &#125;    public Event setTopic(String topic) &#123;        this.topic = topic;        return this;    &#125;    public int getUserId() &#123;        return userId;    &#125;    public Event setUserId(int userId) &#123;        this.userId = userId;        return this;    &#125;    public int getEntityType() &#123;        return entityType;    &#125;    public Event setEntityType(int entityType) &#123;        this.entityType = entityType;        return this;    &#125;    public int getEntityId() &#123;        return entityId;    &#125;    public Event setEntityId(int entityId) &#123;        this.entityId = entityId;        return this;    &#125;    public int getEntityUserId() &#123;        return entityUserId;    &#125;    public Event setEntityUserId(int entityUserId) &#123;        this.entityUserId = entityUserId;        return this;    &#125;    public Map&lt;String, Object&gt; getData() &#123;        return data;    &#125;    public Event setData(String key, Object value) &#123;        this.data.put(key, value);        return this;    &#125;&#125;</code></pre><h2 id="更新接口 -CommunityConstant"><a href="# 更新接口 -CommunityConstant" class="headerlink" title="更新接口 CommunityConstant"></a>更新接口 CommunityConstant</h2><ul><li>在接口中新增三个常量，代表三个主题：评论、点赞、关注。</li></ul><pre><code class="java">/** * 主题: 评论 */String TOPIC_COMMENT = &quot;comment&quot;;/** * 主题: 点赞 */String TOPIC_LIKE = &quot;like&quot;;/** * 主题: 关注 */String TOPIC_FOLLOW = &quot;follow&quot;;</code></pre><h2 id="创建事件生产者类 -EventProducer"><a href="# 创建事件生产者类 -EventProducer" class="headerlink" title="创建事件生产者类 EventProducer"></a>创建事件生产者类 EventProducer</h2><ul><li>新增方法 <code>fireEvent(Event event)</code> ：通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的方法 <code>send()</code> 发送。</li></ul><pre><code class="java">@Componentpublic class EventProducer &#123;    @Autowired    private KafkaTemplate kafkaTemplate;    // 处理事件    public void fireEvent(Event event) &#123;        // 将事件发布到指定的主题        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));    &#125;&#125;</code></pre><h2 id="更新表现层的 -CommentController、LikeController、FollowController"><a href="# 更新表现层的 -CommentController、LikeController、FollowController" class="headerlink" title="更新表现层的 CommentController、LikeController、FollowController"></a>更新表现层的 CommentController、LikeController、FollowController</h2><ul><li>注入 EventProducer 实例。</li><li>重构表现层 CommentController 类的方法 <code>addComment()</code>  ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/add/&#123;discussPostId&#125;&quot;)public String addComment(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Comment comment) &#123;    comment.setUserId(hostHolder.getUser().getId());    comment.setStatus(0);    comment.setCreateTime(new Date());    commentService.addComment(comment);    // 触发评论事件    Event event = new Event()            .setTopic(TOPIC_COMMENT)            .setUserId(hostHolder.getUser().getId())            .setEntityType(comment.getEntityType())            .setEntityId(comment.getEntityId())            .setData(&quot;postId&quot;, discussPostId);    if (comment.getEntityType() == ENTITY_TYPE_POST) &#123;        DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125; else if (comment.getEntityType() == ENTITY_TYPE_COMMENT) &#123;        Comment target = commentService.findCommentById(comment.getEntityId());        event.setEntityUserId(target.getUserId());    &#125;    eventProducer.fireEvent(event);    return &quot;redirect:/discuss/detail/&quot; + discussPostId;&#125;</code></pre><ul><li>重构表现层 LikeController 类的方法 <code>like()</code>  ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/like&quot;)@ResponseBodypublic String like(int entityType, int entityId, int entityUserId, int postId) &#123;    User user = hostHolder.getUser();    // 点赞    likeService.like(user.getId(), entityType, entityId, entityUserId);    // 数量    long likeCount = likeService.findEntityLikeCount(entityType, entityId);    // 状态    int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);    // 返回的结果    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;likeCount&quot;, likeCount);    map.put(&quot;likeStatus&quot;, likeStatus);    // 触发点赞事件    if (likeStatus == 1) &#123;        Event event = new Event()                .setTopic(TOPIC_LIKE)                .setUserId(hostHolder.getUser().getId())                .setEntityType(entityType)                .setEntityId(entityId)                .setEntityUserId(entityUserId)                .setData(&quot;postId&quot;, postId);        eventProducer.fireEvent(event);    &#125;    return CommunityUtil.getJSONString(0, null, map);&#125;</code></pre><ul><li>重构表现层 FollowController 类的方法 <code>follow()</code> ，封装 Event 对象，然后调用 EventProducer 类的 <code>fireEvent()</code>  方法发布通知。</li></ul><pre><code class="java">@PostMapping(&quot;/follow&quot;)@ResponseBodypublic String follow(int entityType, int entityId) &#123;    User user = hostHolder.getUser();    followService.follow(user.getId(), entityType, entityId);    // 触发关注事件    Event event = new Event()            .setTopic(TOPIC_FOLLOW)            .setUserId(hostHolder.getUser().getId())            .setEntityType(entityType)            .setEntityId(entityId)            .setEntityUserId(entityId);    eventProducer.fireEvent(event);    return CommunityUtil.getJSONString(0, &quot; 已关注!&quot;);&#125;</code></pre><h2 id="创建事件消费者类 -EventConsumer"><a href="# 创建事件消费者类 -EventConsumer" class="headerlink" title="创建事件消费者类 EventConsumer"></a>创建事件消费者类 EventConsumer</h2><ul><li>注入 MessageService 实例。</li><li>新增方法 <code>handleCommentMessage(ConsumerRecord record)</code> ：通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 record 中获取信息，封装成 Message 对象然后调用方法 <code>addMessage()</code> 插入数据库。</li></ul><pre><code class="java">@Componentpublic class EventConsumer implements CommunityConstant &#123;    private static final Logger logger = LoggerFactory.getLogger(EventConsumer.class);    @Autowired    private MessageService messageService;    @KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)    public void handleCommentMessage(ConsumerRecord record) &#123;        if (record == null || record.value() == null) &#123;            logger.error(&quot; 消息的内容为空!&quot;);            return;        &#125;        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) &#123;            logger.error(&quot; 消息格式错误!&quot;);            return;        &#125;        // 发送站内通知        Message message = new Message();        message.setFromId(SYSTEM_USER_ID);        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        message.setCreateTime(new Date());        Map&lt;String, Object&gt; content = new HashMap&lt;&gt;();        content.put(&quot;userId&quot;, event.getUserId());        content.put(&quot;entityType&quot;, event.getEntityType());        content.put(&quot;entityId&quot;, event.getEntityId());        if (!event.getData().isEmpty()) &#123;            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;                content.put(entry.getKey(), entry.getValue());            &#125;        &#125;        message.setContent(JSONObject.toJSONString(content));        messageService.addMessage(message);    &#125;&#125;</code></pre><h1 id="2- 显示系统通知"><a href="#2- 显示系统通知" class="headerlink" title="2. 显示系统通知"></a>2. 显示系统通知</h1><ol><li>通知列表：显示评论、点赞、关注三种类型的通知。</li><li>通知详情：分页显示某一类主题所包含的通知。</li><li>未读消息：在页面头部显示所有未读消息的数量。</li></ol><h2 id="更新接口 -MessageMapper"><a href="# 更新接口 -MessageMapper" class="headerlink" title="更新接口 MessageMapper"></a>更新接口 MessageMapper</h2><ul><li>新增方法 <code>selectLatestNotice(int userId, String topic)</code> ，查询某主题最新的通知。</li><li>新增方法 <code>selectNoticeCount(int userId, String topic)</code> ，查询某主题通知的数量。</li><li>新增方法 <code>selectNoticeUnreadCount(int userId, String topic)</code> ，查询未读通知的数量。</li></ul><pre><code class="java">// 查询某个主题下最新的通知Message selectLatestNotice(int userId, String topic);// 查询某个主题所包含的通知数量int selectNoticeCount(int userId, String topic);// 查询未读的通知的数量int selectNoticeUnreadCount(int userId, String topic);</code></pre><ul><li>在 <code>message-mapper.xml</code> 配置三个方法的 sql 语句，其中查询未读通知时使用 if 动态语句，如果没有传入 topic 就查询未读总量。</li></ul><pre><code class="xml">&lt;sql id=&quot;selectFields&quot;&gt;    id, from_id, to_id, conversation_id, content, status, create_time&lt;/sql&gt;&lt;select id=&quot;selectLatestNotice&quot; resultType=&quot;Message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where id in (select max(id) from message        where status != 2        and from_id = 1        and to_id = #&#123;userId&#125;        and conversation_id = #&#123;topic&#125;    )&lt;/select&gt;&lt;select id=&quot;selectNoticeCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;&lt;/select&gt;&lt;select id=&quot;selectNoticeUnreadCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status = 0    and from_id = 1    and to_id = #&#123;userId&#125;    &lt;if test=&quot;topic!=null&quot;&gt;        and conversation_id = #&#123;topic&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre><h2 id="更新业务层的 -MessageService- 类"><a href="# 更新业务层的 -MessageService- 类" class="headerlink" title="更新业务层的 MessageService 类"></a>更新业务层的 MessageService 类</h2><ul><li>新增方法 <code>findLatestNotice()</code> ，调用方法 <code>selectLatestNotice()</code> 查询最新通知。</li><li>新增方法 <code>findNoticeCount()</code> ，调用方法 <code>selectNoticeCount()</code> 查询某主题通知的数量。</li><li>新增方法 <code>findNoticeUnreadCount()</code> ，调用方法 <code>selectNoticeUnreadCount()</code> 查询未读通知的数量。</li></ul><pre><code class="java">public Message findLatestNotice(int userId, String topic) &#123;    return messageMapper.selectLatestNotice(userId, topic);&#125;public int findNoticeCount(int userId, String topic) &#123;    return messageMapper.selectNoticeCount(userId, topic);&#125;public int findNoticeUnreadCount(int userId, String topic) &#123;    return messageMapper.selectNoticeUnreadCount(userId, topic);&#125;</code></pre><h2 id="更新表现层的 -MessageController- 类"><a href="# 更新表现层的 -MessageController- 类" class="headerlink" title="更新表现层的 MessageController 类"></a>更新表现层的 MessageController 类</h2><ul><li>新增方法 <code>getNoticeList()</code> ：获取通知列表。<ul><li>调用业务层的 MessageService 类的方法查询评论、点赞、关注的通知，将其封装在一个 HashMap 集合中然后添加到 Model 对象中。</li><li>调用业务层的 MessageService 类的方法查询私信和通知的总未读数量，添加到 Model 对象中。</li><li>返回 <code>notice.html</code> 页面。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/notice/list&quot;)public String getNoticeList(Model model) &#123;    User user = hostHolder.getUser();    // 查询评论类通知    Message message = messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);    Map&lt;String, Object&gt; messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;commentNotice&quot;, messageVO);    // 查询点赞类通知    message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);    messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_LIKE);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;likeNotice&quot;, messageVO);    // 查询关注类通知    message = messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);    messageVO = new HashMap&lt;&gt;();    if (message != null) &#123;        messageVO.put(&quot;message&quot;, message);        String content = HtmlUtils.htmlUnescape(message.getContent());        Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));        int count = messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);        messageVO.put(&quot;count&quot;, count);        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);        messageVO.put(&quot;unread&quot;, unread);    &#125;    model.addAttribute(&quot;followNotice&quot;, messageVO);    // 查询私信的总未读数    int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);    model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);      // 查询通知的总未读数    int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);    model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);    return &quot;/site/notice&quot;;&#125;</code></pre><h2 id="再次更新接口 -MessageMapper"><a href="# 再次更新接口 -MessageMapper" class="headerlink" title="再次更新接口 MessageMapper"></a>再次更新接口 MessageMapper</h2><ul><li>新增方法 <code>selectNotices()</code> ：查询某个主题的通知列表。</li><li>在 <code>message-mapper.xml</code> 文件中配置 SQL。</li></ul><pre><code class="java">// 查询某个主题所包含的通知列表List&lt;Message&gt; selectNotices(int userId, String topic, int offset, int limit);</code></pre><pre><code class="xml">&lt;select id=&quot;selectNotices&quot; resultType=&quot;Message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;    order by create_time desc    limit #&#123;offset&#125;, #&#123;limit&#125;&lt;/select&gt;</code></pre><h2 id="再次更新业务层的 -MessageService- 类"><a href="# 再次更新业务层的 -MessageService- 类" class="headerlink" title="再次更新业务层的 MessageService 类"></a>再次更新业务层的 MessageService 类 </h2><p> 新增方法 <code>findNotices()</code> ：调用方法 <code>selectNotices()</code> 。</p><pre><code class="java">public List&lt;Message&gt; findNotices(int userId, String topic, int offset, int limit) &#123;    return messageMapper.selectNotices(userId, topic, offset, limit);&#125;</code></pre><h2 id="再次更新业务层的 -MessageController- 类"><a href="# 再次更新业务层的 -MessageController- 类" class="headerlink" title="再次更新业务层的 MessageController 类"></a>再次更新业务层的 MessageController 类</h2><ul><li>新增方法 <code>getNoticeDetail()</code> ：<ul><li>调用方法 <code>findNotices()</code> 获取通知列表详情，封装到 List 集合并存入 Model 对象。</li><li>从通知集合中获取 id 集合，调用方法 <code>readMessage()</code> 将消息设为已读。</li><li>返回 <code>notice-detail.html</code> 页面。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/notice/detail/&#123;topic&#125;&quot;)public String getNoticeDetail(@PathVariable(&quot;topic&quot;) String topic, Page page, Model model) &#123;    User user = hostHolder.getUser();    page.setLimit(5);    page.setPath(&quot;/notice/detail/&quot; + topic);    page.setRows(messageService.findNoticeCount(user.getId(), topic));    List&lt;Message&gt; noticeList = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; noticeVoList = new ArrayList&lt;&gt;();    if (noticeList != null) &#123;        for (Message notice : noticeList) &#123;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            // 通知            map.put(&quot;notice&quot;, notice);            // 内容            String content = HtmlUtils.htmlUnescape(notice.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            map.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));            map.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));            map.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));            map.put(&quot;postId&quot;, data.get(&quot;postId&quot;));            // 通知作者            map.put(&quot;fromUser&quot;, userService.findUserById(notice.getFromId()));            noticeVoList.add(map);        &#125;    &#125;    model.addAttribute(&quot;notices&quot;, noticeVoList);    // 设置已读    List&lt;Integer&gt; ids = getLetterIds(noticeList);    if (!ids.isEmpty()) &#123;        messageService.readMessage(ids);    &#125;    return &quot;/site/notice-detail&quot;;&#125;</code></pre><h2 id="创建表现层的拦截器 -MessageInterceptor- 类"><a href="# 创建表现层的拦截器 -MessageInterceptor- 类" class="headerlink" title="创建表现层的拦截器 MessageInterceptor 类"></a>创建表现层的拦截器 MessageInterceptor 类</h2><ul><li>注入 MessageService 实例和 HostHolder 实例。</li><li>重写方法 <code>postHandle()</code> ，查询私信和通知的未读数量和，然后添加到 ModelAndView 对象。</li></ul><pre><code class="java">@Componentpublic class MessageInterceptor implements HandlerInterceptor &#123;    @Autowired    private HostHolder hostHolder;    @Autowired    private MessageService messageService;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        User user = hostHolder.getUser();        if (user != null &amp;&amp; modelAndView != null) &#123;            int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);            int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);            modelAndView.addObject(&quot;allUnreadCount&quot;, letterUnreadCount + noticeUnreadCount);        &#125;    &#125;&#125;</code></pre><h2 id="更新配置类 -WebConfig"><a href="# 更新配置类 -WebConfig" class="headerlink" title="更新配置类 WebConfig"></a>更新配置类 WebConfig</h2><ul><li>注入 MessageInterceptor 实例。</li><li>在方法 <code>addInterceptors()</code> 中添加拦截器 MessageInterceptor 实例。</li></ul><pre><code class="java">@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(alphaInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;)            .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;);    registry.addInterceptor(loginTicketInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    registry.addInterceptor(loginRequiredInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);    registry.addInterceptor(messageInterceptor)            .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园社区论坛项目之 Redis</title>
      <link href="/2023/03/07/community4/"/>
      <url>/2023/03/07/community4/</url>
      
        <content type="html"><![CDATA[<p>🌟 本帖记录 Spring Boot 整合 Redis 实现校园社区论坛项目的点赞、关注功能，同时优化了登录模块中的验证码存储、登录凭证存储、用户信息缓存功能。</p><p>🌟 准备工作：</p><ol><li>引入 Redis 依赖到 pom.xml 文件中：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在 application.properties 文件中配置 Redis：</li></ol><pre><code class="properties"># RedisPropertiesspring.redis.database=11spring.redis.host=localhostspring.redis.port=6379</code></pre><ol start="3"><li>编写配置类 RedisConfig：</li></ol><pre><code class="java">@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        // 设置 key 的序列化方式        template.setKeySerializer(RedisSerializer.string());        // 设置 value 的序列化方式        template.setValueSerializer(RedisSerializer.json());        // 设置 hash 的 key 的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        // 设置 hash 的 value 的序列化方式        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        return template;    &#125;&#125;</code></pre><h1 id="1- 点赞"><a href="#1- 点赞" class="headerlink" title="1. 点赞"></a>1. 点赞 </h1><p> 点赞模块包含：</p><ol><li>点赞：(1)支持对帖子、评论进行点赞；(2)第一次点击“赞”完成点赞操作，第二次点击“已赞”完成取消点赞操作。</li><li>首页：统计帖子的点赞数。</li><li>详情页：(1)统计帖子的点赞数；(2)显示点赞状态。</li></ol><h2 id="创建工具类 -RedisKeyUtil"><a href="# 创建工具类 -RedisKeyUtil" class="headerlink" title="创建工具类 RedisKeyUtil"></a>创建工具类 RedisKeyUtil</h2><ul><li>定义分隔符 <code>:</code></li><li>定义实体获得赞的 key 前缀常量  <code>like:entity</code></li><li>新增方法 <code>getEntityLikeKey(int entityType, int entityId)</code>，通过实体类型和实体 id 生成对应实体获得赞的 key，这个 key 的呈现形式为 <code>like:entity:entityType:entityId</code>。</li></ul><pre><code class="jade">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;&#125;</code></pre><h2 id="创建业务层的 -LikeService- 类"><a href="# 创建业务层的 -LikeService- 类" class="headerlink" title="创建业务层的 LikeService 类"></a>创建业务层的 LikeService 类</h2><ul><li>注入 <code>RedisTemplate</code> 实例</li><li>新增方法 <code>like()</code> 实现点赞功能：<ul><li>首先，调用工具类 <code>RedisKeyUtil</code> 中的方法 <code>getEntityLikeKey()</code> 获得实体点赞的 key；</li><li>然后，通过 <code>RedisTemplate</code> 的对象，调用 set 集合的方法 <code>isMember()</code> 查询 userId 是否存在于对应 key 的 set 集合中，如果存在则移出点赞的用户集合，如果不存在则添加到点赞的用户集合中。</li></ul></li><li>新增方法 <code>findEntityLikeCount()</code>：查询某实体的点赞数，通过调用 set 集合的方法 <code>size()</code> 查询元素的个数。</li><li>新增方法 <code>findEntityLikeStatus()</code>：查询某用户对某实体的点赞状态，逻辑实现同方法<code>like()</code>，即通过调用 set 集合的方法 <code>isMember()</code> 实现。</li></ul><pre><code class="java">@Servicepublic class LikeService &#123;    @Autowired    private RedisTemplate redisTemplate;    // 点赞    public void like(int userId, int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);      // 判断是否点过赞        if (isMember) &#123;            redisTemplate.opsForSet().remove(entityLikeKey, userId);        &#125; else &#123;            redisTemplate.opsForSet().add(entityLikeKey, userId);        &#125;    &#125;    // 查询某实体点赞的数量    public long findEntityLikeCount(int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().size(entityLikeKey);    &#125;    // 查询某人对某实体的点赞状态    public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);          // 1 表示已赞；0 表示未赞        return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;    &#125;&#125;</code></pre><h2 id="创建表现层的 -LikeController- 类"><a href="# 创建表现层的 -LikeController- 类" class="headerlink" title="创建表现层的 LikeController 类"></a>创建表现层的 LikeController 类</h2><ul><li>注入 <code>LikeService</code> 和 <code>HostHolder</code> 实例</li><li>新增方法 <code>like()</code>：实现点赞功能，调用业务层的方法 <code>like()</code> 进行点赞，调用 <code>findEntityLikeCount()</code> 和 <code>findEntityLikeStatus()</code> 查询点赞数和点赞状态，并封装到 map 集合中，然后通过工具类封装成 JSON 数据返回。</li></ul><pre><code class="java">@Controllerpublic class LikeController &#123;    @Autowired    private LikeService likeService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/like&quot;)    @ResponseBody    public String like(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        // 点赞        likeService.like(user.getId(), entityType, entityId);        // 数量        long likeCount = likeService.findEntityLikeCount(entityType, entityId);        // 状态        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        // 返回的结果        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;, likeCount);        map.put(&quot;likeStatus&quot;, likeStatus);        return CommunityUtil.getJSONString(0, null, map);    &#125;&#125;</code></pre><h2 id="更新表现层的 -HomeController- 类"><a href="# 更新表现层的 -HomeController- 类" class="headerlink" title="更新表现层的 HomeController 类"></a>更新表现层的 HomeController 类</h2><ul><li><p>注入  <code>LikeService</code> 实例</p></li><li><p>更新方法  <code>getIndexPage()</code>：新增更新首页帖子点赞数功能，调用业务层的 <code>LikeService</code> 类的方法获得点赞数，并存储到 map 集合中。</p></li></ul><pre><code class="java">@GetMapping(&quot;/index&quot;)public String getIndexPage(Model model, Page page) &#123;    // 方法调用之前，SpringMVC 会自动实例化 Model 和 Page，并将 Page 注入到 Model 中。    // 所以，在 thymeleaf 中可以直接访问 Page 对象中的数据.    page.setRows(discussPostService.findDiscussPostRows(0));    page.setPath(&quot;/index&quot;);    List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;();    if (list != null) &#123;        for (DiscussPost post : list) &#123;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;post&quot;, post);            User user = userService.findUserById(post.getUserId());            map.put(&quot;user&quot;, user);            long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());            map.put(&quot;likeCount&quot;, likeCount);            discussPosts.add(map);        &#125;    &#125;    model.addAttribute(&quot;discussPosts&quot;, discussPosts);    return &quot;/index&quot;;&#125;</code></pre><h2 id="更新表现层的 -DiscussPostController- 类"><a href="# 更新表现层的 -DiscussPostController- 类" class="headerlink" title="更新表现层的 DiscussPostController 类"></a>更新表现层的 DiscussPostController 类</h2><ul><li>注入  <code>LikeService</code> 实例</li><li>更新方法 <code>addDiscussPost()</code>：新增更新详情页帖子（评论、回复）的点赞数功能，调用业务层的 <code>LikeService</code> 类的方法获得点赞数和点赞状态，并将其存入视图对象中。</li></ul><pre><code class="java">@GetMapping(&quot;/detail/&#123;discussPostId&#125;&quot;)public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) &#123;    // 帖子    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);    model.addAttribute(&quot;post&quot;, post);    // 作者    User user = userService.findUserById(post.getUserId());    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    // 点赞状态    int likeStatus = hostHolder.getUser() == null ? 0 :            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);    model.addAttribute(&quot;likeStatus&quot;, likeStatus);    // 评论分页信息    page.setLimit(5);    page.setPath(&quot;/discuss/detail/&quot; + discussPostId);    page.setRows(post.getCommentCount());    // 评论: 给帖子的评论    // 回复: 给评论的评论    // 评论列表    List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());    // 评论 VO 列表    List&lt;Map&lt;String, Object&gt;&gt; commentVoList = new ArrayList&lt;&gt;();    if (commentList != null) &#123;        for (Comment comment : commentList) &#123;            // 评论 VO            Map&lt;String, Object&gt; commentVo = new HashMap&lt;&gt;();            // 评论            commentVo.put(&quot;comment&quot;, comment);            // 作者            commentVo.put(&quot;user&quot;, userService.findUserById(comment.getUserId()));            // 点赞数量            likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;likeCount&quot;, likeCount);            // 点赞状态            likeStatus = hostHolder.getUser() == null ? 0 :                    likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;likeStatus&quot;, likeStatus);            // 回复列表            List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);            // 回复 VO 列表            List&lt;Map&lt;String, Object&gt;&gt; replyVoList = new ArrayList&lt;&gt;();            if (replyList != null) &#123;                for (Comment reply : replyList) &#123;                    Map&lt;String, Object&gt; replyVo = new HashMap&lt;&gt;();                    // 回复                    replyVo.put(&quot;reply&quot;, reply);                    // 作者                    replyVo.put(&quot;user&quot;, userService.findUserById(reply.getUserId()));                    // 回复目标                    User target = reply.getTargetId() == 0 ? null : userService.findUserById(reply.getTargetId());                    replyVo.put(&quot;target&quot;, target);                    // 点赞数量                    likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());                    replyVo.put(&quot;likeCount&quot;, likeCount);                    // 点赞状态                    likeStatus = hostHolder.getUser() == null ? 0 :                            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());                    replyVo.put(&quot;likeStatus&quot;, likeStatus);                    replyVoList.add(replyVo);                &#125;            &#125;            commentVo.put(&quot;replys&quot;, replyVoList);            // 回复数量            int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;replyCount&quot;, replyCount);            commentVoList.add(commentVo);        &#125;    &#125;    model.addAttribute(&quot;comments&quot;, commentVoList);    return &quot;/site/discuss-detail&quot;;&#125;</code></pre><h1 id="2- 收到的赞"><a href="#2- 收到的赞" class="headerlink" title="2. 收到的赞"></a>2. 收到的赞</h1><ol><li>重构点赞功能：以用户为 key，记录点赞数量；<code>increment(key)</code>、<code>decrement(key)</code></li><li>开发个人主页：以用户为 key，查询点赞数。</li></ol><h2 id="更新工具类 -RedisUtil"><a href="# 更新工具类 -RedisUtil" class="headerlink" title="更新工具类 RedisUtil"></a>更新工具类 RedisUtil</h2><ul><li><p>新增用户获得赞 key 的前缀常量 <code>like:user</code></p></li><li><p>新增方法 <code>getUserLikeKey(int userId)</code>，通过用户 id 生成对应用户获得赞的 key。</p></li></ul><pre><code class="java">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    private static final String PREFIX_USER_LIKE = &quot;like:user&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;    // 某个用户的赞    // like:user:userId -&gt; int    public static String getUserLikeKey(int userId) &#123;        return PREFIX_USER_LIKE + SPLIT + userId;    &#125;&#125;</code></pre><h2 id="更新业务层的 -LikeService 类"><a href="# 更新业务层的 -LikeService 类" class="headerlink" title="更新业务层的 LikeService 类"></a>更新业务层的 LikeService 类</h2><ul><li>重构方法 <code>like()</code>，在参数列表中新增：entityUserId（表示被点赞用户的 id），该参数用来更新用户的被点赞数量。<ul><li>调用 <code>RedisTemplate</code> 的对象的方法 <code>execute()</code> 实现事务，保证被点赞用户与点赞用户的数据更新保持一致。调用 <code>isMember()</code> 查询用户的点赞状态，之后调用 <code>multi()</code> 开启事务。</li><li>当用户已点赞时，调用方法 <code>remove()</code> 将当前用户从点赞的用户集合中移除，调用方法 <code>decrement()</code> 将被点赞用户的被点赞数减去 1；当用户未点赞时，调用方法 <code>add()</code> 将当前用户添加到点赞的用户集合中，调用方法 <code>increment()</code> 将被点赞用户的点赞数加上 1。</li></ul></li><li>新增方法 <code>findUserLikeCount()</code>，以用户 id 为 key，调用方法 <code>get()</code> 查询用户所获点赞数。</li></ul><pre><code class="java">@Servicepublic class LikeService &#123;    @Autowired    private RedisTemplate redisTemplate;    // 点赞    public void like(int userId, int entityType, int entityId, int entityUserId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);                boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);                operations.multi();                if (isMember) &#123;                    operations.opsForSet().remove(entityLikeKey, userId);                    operations.opsForValue().decrement(userLikeKey);                &#125; else &#123;                    operations.opsForSet().add(entityLikeKey, userId);                    operations.opsForValue().increment(userLikeKey);                &#125;                return operations.exec();            &#125;        &#125;);    &#125;    // 查询某实体点赞的数量    public long findEntityLikeCount(int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().size(entityLikeKey);    &#125;    // 查询某人对某实体的点赞状态    public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;    &#125;    // 查询某个用户获得的赞    public int findUserLikeCount(int userId) &#123;        String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);        Integer count = (Integer) redisTemplate.opsForValue().get(userLikeKey);        return count == null ? 0 : count.intValue();    &#125;&#125;</code></pre><h2 id="更新表现层的 -LikeController- 类"><a href="# 更新表现层的 -LikeController- 类" class="headerlink" title="更新表现层的 LikeController 类"></a>更新表现层的 LikeController 类</h2><ul><li>更新方法 <code>like()</code>：在参数列表中新增参数 entityUserId（表示被点赞用户的 id）。</li></ul><pre><code class="java">@Controllerpublic class LikeController &#123;    @Autowired    private LikeService likeService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/like&quot;)    @ResponseBody    public String like(int entityType, int entityId, int entityUserId) &#123;        User user = hostHolder.getUser();        // 点赞        likeService.like(user.getId(), entityType, entityId, entityUserId);        // 数量        long likeCount = likeService.findEntityLikeCount(entityType, entityId);        // 状态        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        // 返回的结果        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;, likeCount);        map.put(&quot;likeStatus&quot;, likeStatus);        return CommunityUtil.getJSONString(0, null, map);    &#125;&#125;</code></pre><h2 id="更新表现层的 -UserController- 类"><a href="# 更新表现层的 -UserController- 类" class="headerlink" title="更新表现层的 UserController 类"></a>更新表现层的 UserController 类</h2><ul><li>新增方法<code>getProfilePage()</code>：调用业务层的方法查询用户和点赞数，并将两项信息存储于 Model 对象中。</li></ul><pre><code class="java">// 个人主页@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)public String getProfilePage(@PathVariable(&quot;userId&quot;) int userId, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    // 用户    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    int likeCount = likeService.findUserLikeCount(userId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    return &quot;/site/profile&quot;;&#125;</code></pre><h1 id="3- 关注"><a href="#3- 关注" class="headerlink" title="3. 关注"></a>3. 关注 </h1><h2 id="更新工具类 -RedisUtil-1"><a href="# 更新工具类 -RedisUtil-1" class="headerlink" title="更新工具类 RedisUtil"></a> 更新工具类 RedisUtil</h2><ul><li>新增用户关注实体（帖子、评论、用户等）的前缀常量 followee 和粉丝（用户）的前缀常量 follower。</li><li>新增方法 <code>getFolloweeKey(int userId, int entityType)</code>，通过用户 id 和实体类型生成用户关注实体的 key。</li><li>新增方法 <code>getFollowerKey(int entityType, int entityId)</code>，通过实体类型和实体 id 生成实体用户粉丝的 key。</li></ul><pre><code class="java">public class RedisKeyUtil &#123;    private static final String SPLIT = &quot;:&quot;;    private static final String PREFIX_ENTITY_LIKE = &quot;like:entity&quot;;    private static final String PREFIX_USER_LIKE = &quot;like:user&quot;;    private static final String PREFIX_FOLLOWEE = &quot;followee&quot;;    private static final String PREFIX_FOLLOWER = &quot;follower&quot;;    // 某个实体的赞    // like:entity:entityType:entityId -&gt; set(userId)    public static String getEntityLikeKey(int entityType, int entityId) &#123;        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;    &#125;    // 某个用户的赞    // like:user:userId -&gt; int    public static String getUserLikeKey(int userId) &#123;        return PREFIX_USER_LIKE + SPLIT + userId;    &#125;    // 某个用户关注的实体    // followee:userId:entityType -&gt; zset(entityId,now)    public static String getFolloweeKey(int userId, int entityType) &#123;        return PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;    &#125;    // 某个实体拥有的粉丝    // follower:entityType:entityId -&gt; zset(userId,now)    public static String getFollowerKey(int entityType, int entityId) &#123;        return PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;    &#125;&#125;</code></pre><h2 id="创建业务层的 -FollowService- 类"><a href="# 创建业务层的 -FollowService- 类" class="headerlink" title="创建业务层的 FollowService 类"></a>创建业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>follow()</code>，当用户关注某实体时：</p><ul><li>调用方法 <code>add() </code>将当前实体 id 和时间作为 value 和 score 加入到用户的关注集合中。</li><li>调用方法 <code>add()</code> 将当前用户 id 和时间作为 value 和 score 加入到实体的粉丝集合中。</li></ul></li><li><p>新增方法 <code>unfollow()</code>，当用户取关某实体时：</p><ul><li>调用方法 <code>remove()</code> 将当前实体从用户的关注集合中移除。</li><li>调用方法 <code>remove()</code> 将用户从实体的粉丝集合中移除。</li></ul></li></ul><pre><code class="java">@Servicepublic class FollowService &#123;    @Autowired    private RedisTemplate redisTemplate;    public void follow(int userId, int entityType, int entityId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                operations.multi();                operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());                operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());                return operations.exec();            &#125;        &#125;);    &#125;    public void unfollow(int userId, int entityType, int entityId) &#123;        redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                operations.multi();                operations.opsForZSet().remove(followeeKey, entityId);                operations.opsForZSet().remove(followerKey, userId);                return operations.exec();            &#125;        &#125;);    &#125;&#125;</code></pre><h2 id="创建表现层的 -FollowController"><a href="# 创建表现层的 -FollowController" class="headerlink" title="创建表现层的 FollowController"></a>创建表现层的 FollowController</h2><ul><li>新增方法 <code>follow()</code>：调用 HostHolder 对象的方法获取用户，调用业务层的 <code>FollowService</code> 类的对象的方法 <code>follow()</code> 实现点赞的功能。</li><li>新增方法 <code>unfollow()</code>：调用 HostHolder 对象的方法获取用户，调用业务层的 <code>FollowService</code> 类的对象的方法 <code>unfollow()</code> 实现取消点赞的功能。</li></ul><pre><code class="java">@Controllerpublic class FollowController &#123;    @Autowired    private FollowService followService;    @Autowired    private HostHolder hostHolder;    @PostMapping(&quot;/follow&quot;)    @ResponseBody    public String follow(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        followService.follow(user.getId(), entityType, entityId);        return CommunityUtil.getJSONString(0, &quot; 已关注!&quot;);    &#125;    @PostMapping(&quot;/unfollow&quot;)    @ResponseBody    public String unfollow(int entityType, int entityId) &#123;        User user = hostHolder.getUser();        followService.unfollow(user.getId(), entityType, entityId);        return CommunityUtil.getJSONString(0, &quot; 已取消关注!&quot;);    &#125;&#125;</code></pre><h1 id="4- 个人主页"><a href="#4- 个人主页" class="headerlink" title="4. 个人主页"></a>4. 个人主页 </h1><h2 id="更新业务层的 -FollowService- 类"><a href="# 更新业务层的 -FollowService- 类" class="headerlink" title="更新业务层的 FollowService 类"></a> 更新业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>findFolloweeCount()</code>，调用 zset 集合的方法 <code>zcard()</code> 查询某用户关注的实体数量。</p></li><li><p>新增方法 <code>findFollowerCount()</code>，调用 zset 集合的方法 <code>zcard()</code> 查询某实体的粉丝数量。</p></li><li><p>新增方法 <code>hasFollowed()</code>，根据 zset 集合的方法 <code>zscore()</code> 的返回值查询当前用户是否关注了某实体。</p></li></ul><pre><code class="java">// 查询关注的实体的数量public long findFolloweeCount(int userId, int entityType) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().zCard(followeeKey);&#125;// 查询实体的粉丝的数量public long findFollowerCount(int entityType, int entityId) &#123;    String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);    return redisTemplate.opsForZSet().zCard(followerKey);&#125;// 查询当前用户是否已关注该实体public boolean hasFollowed(int userId, int entityType, int entityId) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().score(followeeKey, entityId) != null;&#125;</code></pre><h2 id="更新表现层的 -UserController- 类 -1"><a href="# 更新表现层的 -UserController- 类 -1" class="headerlink" title="更新表现层的 UserController 类"></a>更新表现层的 UserController 类</h2><ul><li><p>调用业务层的 <code>LikeService</code> 类中的方法 <code>findUserLikeCount()</code> 查询用户获赞数，并添加到 Model 中。</p></li><li><p>调用业务层的 <code>FollowService</code> 类中的方法 <code>findFolloweeCount()</code> 查询关注数量，调用方法 <code>findFollowerCount()</code> 查询粉丝数量，调用方法 <code>hasFollowed()</code> 查询用户是否关注，并将三项信息存储于 Model 对象中。</p></li><li><p>更新获取个人主页方法 <code>getProfilePage()</code>：新增关注数、粉丝数、判断是否已关注，并将三项信息存储于 Model 对象中。</p></li></ul><pre><code class="java">// 个人主页@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)public String getProfilePage(@PathVariable(&quot;userId&quot;) int userId, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    // 用户    model.addAttribute(&quot;user&quot;, user);    // 点赞数量    int likeCount = likeService.findUserLikeCount(userId);    model.addAttribute(&quot;likeCount&quot;, likeCount);    // 关注数量    long followeeCount = followService.findFolloweeCount(userId, ENTITY_TYPE_USER);    model.addAttribute(&quot;followeeCount&quot;, followeeCount);    // 粉丝数量    long followerCount = followService.findFollowerCount(ENTITY_TYPE_USER, userId);    model.addAttribute(&quot;followerCount&quot;, followerCount);    // 是否已关注    boolean hasFollowed = false;    if (hostHolder.getUser() != null) &#123;        hasFollowed = followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);    &#125;    model.addAttribute(&quot;hasFollowed&quot;, hasFollowed);    return &quot;/site/profile&quot;;&#125;</code></pre><h1 id="5- 关注列表和粉丝列表"><a href="#5- 关注列表和粉丝列表" class="headerlink" title="5. 关注列表和粉丝列表"></a>5. 关注列表和粉丝列表 </h1><h2 id="更新业务层的 -FollowService- 类 -1"><a href="# 更新业务层的 -FollowService- 类 -1" class="headerlink" title="更新业务层的 FollowService 类"></a> 更新业务层的 FollowService 类</h2><ul><li><p>新增方法 <code>findFollowees()</code>：查询用户关注列表。通过 zset 集合的方法 <code>reverseRange()</code> 获取 value 即关注用户的 userId，再查询出其对应的 user，之后通过 score 获取关注时间，存入 map 集合中，将 map 添加到 list 列表中并返回。</p></li><li><p>新增方法 <code>findFollowers()</code>：查询用户粉丝列表。通过 zset 集合的方法 <code>reverseRange()</code> 获取 value 即粉丝的 userId，再查询出其对应的 user，之后通过 score 获取关注时间，存入 map 集合中，将 map 添加到 list 列表中并返回。</p></li><li><p>新增方法 <code>hasFollowed()</code>，根据 zset 集合的方法 <code>zscore()</code> 的返回值查询当前用户是否关注了某实体。</p></li></ul><pre><code class="java">// 查询某用户关注的人public List&lt;Map&lt;String, Object&gt;&gt; findFollowees(int userId, int offset, int limit) &#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - 1);    if (targetIds == null) &#123;        return null;    &#125;    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (Integer targetId : targetIds) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        User user = userService.findUserById(targetId);        map.put(&quot;user&quot;, user);        Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);        map.put(&quot;followTime&quot;, new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;// 查询某用户的粉丝public List&lt;Map&lt;String, Object&gt;&gt; findFollowers(int userId, int offset, int limit) &#123;    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - 1);    if (targetIds == null) &#123;        return null;    &#125;    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (Integer targetId : targetIds) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        User user = userService.findUserById(targetId);        map.put(&quot;user&quot;, user);        Double score = redisTemplate.opsForZSet().score(followerKey, targetId);        map.put(&quot;followTime&quot;, new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;</code></pre><h2 id="更新表现层的 -FollowController- 类"><a href="# 更新表现层的 -FollowController- 类" class="headerlink" title="更新表现层的 FollowController 类"></a>更新表现层的 FollowController 类</h2><ul><li>新增方法 <code>getFollowees()</code>，获取关注列表，存入 Model 对象中。</li><li>新增方法 <code>getFollowers()</code>，获取粉丝列表，存入 Model 对象中。</li></ul><pre><code class="java">@GetMapping(&quot;/followees/&#123;userId&#125;&quot;)public String getFollowees(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    model.addAttribute(&quot;user&quot;, user);    page.setLimit(5);    page.setPath(&quot;/followees/&quot; + userId);    page.setRows((int) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowees(userId, page.getOffset(), page.getLimit());    if (userList != null) &#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            User u = (User) map.get(&quot;user&quot;);            map.put(&quot;hasFollowed&quot;, hasFollowed(u.getId()));        &#125;    &#125;    model.addAttribute(&quot;users&quot;, userList);    return &quot;/site/followee&quot;;&#125;@GetMapping(&quot;/followers/&#123;userId&#125;&quot;)public String getFollowers(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;    User user = userService.findUserById(userId);    if (user == null) &#123;        throw new RuntimeException(&quot; 该用户不存在!&quot;);    &#125;    model.addAttribute(&quot;user&quot;, user);    page.setLimit(5);    page.setPath(&quot;/followers/&quot; + userId);    page.setRows((int) followService.findFollowerCount(ENTITY_TYPE_USER, userId));    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowers(userId, page.getOffset(), page.getLimit());    if (userList != null) &#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            User u = (User) map.get(&quot;user&quot;);            map.put(&quot;hasFollowed&quot;, hasFollowed(u.getId()));        &#125;    &#125;    model.addAttribute(&quot;users&quot;, userList);    return &quot;/site/follower&quot;;&#125;private boolean hasFollowed(int userId) &#123;    if (hostHolder.getUser() == null) &#123;        return false;    &#125;    return followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);&#125;</code></pre><h1 id="6- 优化登录模块"><a href="#6- 优化登录模块" class="headerlink" title="6. 优化登录模块"></a>6. 优化登录模块</h1><ol><li><p>使用 Redis 存储验证码：验证码需要频繁访问与刷新，对性能要求较高；验证码不需要永久保存，通常在很短的时间内就会失效；分布式部署时，存在 Session 共享的问题。</p></li><li><p>使用 Redis 存储登录凭证：处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。</p></li><li><p>使用 Redis 缓存用户信息：每次处理请求时，都要根据凭证查询用户信息，访问的频率非常高。</p></li></ol><h2 id="6-1- 存储验证码"><a href="#6-1- 存储验证码" class="headerlink" title="6.1 存储验证码"></a>6.1 存储验证码</h2><ul><li>更新工具类 RedisUtil<ul><li>新增验证码前缀常量 <code>kaptcha</code></li><li>新增方法 <code>getKaptchaKey()</code>，通过用户凭证（由于未登录，采用 cookie 实现）获得对应验证码的 key（利用 String 存储验证码）。</li></ul></li></ul><pre><code class="java">private static final String PREFIX_KAPTCHA = &quot;kaptcha&quot;;// 登录验证码public static String getKaptchaKey(String owner) &#123;    return PREFIX_KAPTCHA + SPLIT + owner;&#125;</code></pre><ul><li>更新表现层的 LoginController 类<ul><li>重构方法 <code>getKaptcha()</code>，将验证码存入 redis，key 为当前随机生成的字符串，同时将该字符串存入 cookie。</li><li>重构方法 <code>login()</code>，从 cookie 中获取随机字符串，生成验证码的 key，然后获取 key 对应的 value 即验证码。</li></ul></li></ul><pre><code class="java">@GetMapping(&quot;/kaptcha&quot;)public void getKaptcha(HttpServletResponse response/*, HttpSession session*/) &#123;    // 生成验证码    String text = kaptchaProducer.createText();    BufferedImage image = kaptchaProducer.createImage(text);    // 原来的做法：将验证码存入 session    // session.setAttribute(&quot;kaptcha&quot;, text);    // 验证码的归属    String kaptchaOwner = CommunityUtil.generateUUID();    Cookie cookie = new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);    cookie.setMaxAge(60);    cookie.setPath(contextPath);    response.addCookie(cookie);    // 将验证码存入 Redis    String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);    redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);    // 将图片输出给浏览器    response.setContentType(&quot;image/png&quot;);    try &#123;        OutputStream os = response.getOutputStream();        ImageIO.write(image, &quot;png&quot;, os);    &#125; catch (IOException e) &#123;        logger.error(&quot; 响应验证码失败:&quot; + e.getMessage());    &#125;&#125;@PostMapping(&quot;/login&quot;)public String login(String username, String password, String code, boolean rememberme,                    Model model, /*HttpSession session, */HttpServletResponse response,                    @CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner) &#123;    // 检查验证码    // String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);    String kaptcha = null;    if (StringUtils.isNotBlank(kaptchaOwner)) &#123;        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);        kaptcha = (String) redisTemplate.opsForValue().get(redisKey);    &#125;    if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123;        model.addAttribute(&quot;codeMsg&quot;, &quot; 验证码不正确!&quot;);        return &quot;/site/login&quot;;    &#125;    // 检查账号, 密码    int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);    if (map.containsKey(&quot;ticket&quot;)) &#123;        Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());        cookie.setPath(contextPath);        cookie.setMaxAge(expiredSeconds);        response.addCookie(cookie);        return &quot;redirect:/index&quot;;    &#125; else &#123;        model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;));        model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;));        return &quot;/site/login&quot;;    &#125;&#125;</code></pre><h2 id="6-2- 存储登录凭证"><a href="#6-2- 存储登录凭证" class="headerlink" title="6.2 存储登录凭证"></a>6.2 存储登录凭证</h2><ul><li>更新工具类 RedisUtil<ul><li>新增登录凭证前缀常量 <code>ticket</code></li><li>新增方法 <code>getTicketKey</code>() ，通过字符串获得登录凭证的对应 key （利用 String 存储）。</li></ul></li></ul><pre><code class="java">private static final String PREFIX_TICKET = &quot;ticket&quot;;// 登录的凭证public static String getTicketKey(String ticket) &#123;    return PREFIX_TICKET + SPLIT + ticket;&#125;</code></pre><ul><li><p>更新业务层的 UserService 类</p><ul><li><p>重构方法 <code>login()</code> ，将登录凭证存入 redis 中。</p></li><li><p>重构方法 <code>logout</code>() ，先从 redis 中获取登录凭证对象，将状态设为无效再重新存储进 redis。</p></li><li><p>重构方法 <code>findLoginTicket</code>() ，根据 ticket 字符串获得对应登录凭证的 key，然后从 redis 查询登录凭证。</p></li></ul></li></ul><pre><code class="java">public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) &#123;    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    // 空值处理    if (StringUtils.isBlank(username)) &#123;        map.put(&quot;usernameMsg&quot;, &quot; 账号不能为空!&quot;);        return map;    &#125;    if (StringUtils.isBlank(password)) &#123;        map.put(&quot;passwordMsg&quot;, &quot; 密码不能为空!&quot;);        return map;    &#125;    // 验证账号    User user = userMapper.selectByName(username);    if (user == null) &#123;        map.put(&quot;usernameMsg&quot;, &quot; 该账号不存在!&quot;);        return map;    &#125;    // 验证状态    if (user.getStatus() == 0) &#123;        map.put(&quot;usernameMsg&quot;, &quot; 该账号未激活!&quot;);        return map;    &#125;    // 验证密码    password = CommunityUtil.md5(password + user.getSalt());    if (!user.getPassword().equals(password)) &#123;        map.put(&quot;passwordMsg&quot;, &quot; 密码不正确!&quot;);        return map;    &#125;    // 生成登录凭证    LoginTicket loginTicket = new LoginTicket();    loginTicket.setUserId(user.getId());    loginTicket.setTicket(CommunityUtil.generateUUID());    loginTicket.setStatus(0);    loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));        // loginTicketMapper.insertLoginTicket(loginTicket);    String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());    redisTemplate.opsForValue().set(redisKey, loginTicket);    map.put(&quot;ticket&quot;, loginTicket.getTicket());    return map;&#125;public void logout(String ticket) &#123;        // loginTicketMapper.updateStatus(ticket, 1);    String redisKey = RedisKeyUtil.getTicketKey(ticket);    LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);    loginTicket.setStatus(1);    redisTemplate.opsForValue().set(redisKey, loginTicket);&#125;public LoginTicket findLoginTicket(String ticket) &#123;        // return loginTicketMapper.selectByTicket(ticket);    String redisKey = RedisKeyUtil.getTicketKey(ticket);    return (LoginTicket) redisTemplate.opsForValue().get(redisKey);&#125;public int updateHeader(int userId, String headerUrl) &#123;        // return userMapper.updateHeader(userId, headerUrl);    int rows = userMapper.updateHeader(userId, headerUrl);    clearCache(userId);    return rows;&#125;</code></pre><h2 id="6-3- 缓存用户信息"><a href="#6-3- 缓存用户信息" class="headerlink" title="6.3 缓存用户信息"></a>6.3 缓存用户信息</h2><ul><li><p>更新工具类 RedisUtil </p><ul><li><p>新增用户前缀常量 <code>user</code></p></li><li><p>新增 <code>getUserKey</code> 方法，通过用户 id 获得用户的对应 key 值（利用 String 存储）。</p></li></ul></li></ul><pre><code class="java">private static final String PREFIX_USER = &quot;user&quot;;// 用户public static String getUserKey(int userId) &#123;    return PREFIX_USER + SPLIT + userId;&#125;</code></pre><ul><li><p>更新业务层的 UserService 类</p><ul><li><p>新增 <code>getCache</code>()，从缓存获取用户信息。</p></li><li><p>新增 <code>initCache()</code>，从 MySQL 查询用户信息并存入 redis。</p></li><li><p>新增 <code>clearCache()</code>，用户信息变更（更新头像，激活）时清除缓存。</p></li><li><p>重构 <code>findUserById()</code> 方法，首先调用 <code>getCache()</code>从缓存获取用户信息，如果获取为 null 则调用 <code>initCache()</code>。</p></li></ul></li></ul><pre><code class="java">// 1. 优先从缓存中取值private User getCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    return (User) redisTemplate.opsForValue().get(redisKey);&#125;// 2. 取不到时初始化缓存数据private User initCache(int userId) &#123;    User user = userMapper.selectById(userId);    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);    return user;&#125;// 3. 数据变更时清除缓存数据private void clearCache(int userId) &#123;    String redisKey = RedisKeyUtil.getUserKey(userId);    redisTemplate.delete(redisKey);&#125;public User findUserById(int id) &#123;        // return userMapper.selectById(id);    User user = getCache(id);    if (user == null) &#123;        user = initCache(id);    &#125;    return user;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式流媒体平台 Kafka</title>
      <link href="/2023/03/07/Kafka/"/>
      <url>/2023/03/07/Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka- 简介"><a href="#Kafka- 简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介 </h1><p>🌟 <a href="http://kafka.apach.org/">Kafka 官网 </a></p><ul><li>Kafka 是一个分布式的流媒体平台。</li><li> 应用场景：消息系统、日志收集、用户行为追踪、流式处理。</li></ul><h1 id="Kafka- 特点"><a href="#Kafka- 特点" class="headerlink" title="Kafka 特点"></a>Kafka 特点 </h1><ul><li> 高吞吐量 </li><li> 消息持久化 </li><li> 高可靠性 </li><li> 高扩展性 </li></ul><h1 id="Kafka- 术语"><a href="#Kafka- 术语" class="headerlink" title="Kafka 术语"></a>Kafka 术语 </h1><ul><li>Broker</li><li>Zookeeper</li><li>Topic</li><li>Partition</li><li>Offset</li><li>Leader Replica</li><li>Follower Replica</li></ul><h1 id="Kafka- 配置"><a href="#Kafka- 配置" class="headerlink" title="Kafka 配置"></a>Kafka 配置 </h1><ol><li> 在 Kafka 安装包下的 config 文件夹下的 <code>zookeeper.properties</code> 文件内修改：</li></ol><pre><code class="properties"># 默认存放路径dataDir=/tmp/zookeeper</code></pre><ol start="2"><li> 在 Kafka 安装包下的 config 文件夹下的 <code>server.properties</code> 文件内修改：</li></ol><pre><code class="properties"># 默认存放路径log.dirs=/tmp/kafka-logs</code></pre><h1 id="Kafka- 常用命令"><a href="#Kafka- 常用命令" class="headerlink" title="Kafka 常用命令"></a>Kafka 常用命令 </h1><ol><li> 打开一个 terminal 窗口，启动 Zookeeper：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ zookeeper-server-start.sh config\zookeeper.properties</code></pre><ol start="2"><li> 打开另一个 terminal 窗口，启动 Kafka：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ zookeeper-server-start.sh config\server.properties</code></pre><ol start="3"><li> 打开另一个 terminal 窗口，发布 topic 为 test，创建 1 个副本，创建 1 个分区：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test</code></pre><ol start="4"><li> 查看是否成功发布 topic：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-topics.sh --list --bootstrap-server localhost:9092</code></pre><pre><code class="sh"># 发布 topic 成功，terminal 显示 testtest</code></pre><ol start="5"><li> 生产者发布消息：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-console-producer.sh --broker-list localhost:9092 --topic test</code></pre><ol start="6"><li> 消费者订阅消息：</li></ol><pre><code class="sh"># cd 到 Kafka 的 bin 目录下，eg: /usr/local/kafka_2.13-3.4.0/bin~$ kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre><h1 id="Windows- 下关于 -Kafka- 的使用注意点"><a href="#Windows- 下关于 -Kafka- 的使用注意点" class="headerlink" title="Windows 下关于 Kafka 的使用注意点"></a>Windows 下关于 Kafka 的使用注意点 </h1><ul><li> 问题：在 Windows 的命令行里启动 Kafka 之后，当关闭命令行窗口时，就会强制关闭 Kafka。这种关闭方式为暴力关闭，很可能会导致 Kafka 无法完成对日志文件的解锁。届时，再次启动 Kafka 的时候，就会提示日志文件被锁，无法成功启动。</li><li> 方案：将 Kafka 的日志文件全部删除，再次启动即可。</li><li> 建议：不要暴力关闭 Kafka，建议通过在命令行执行 <code>kafka-server-stop</code> 命令来关闭它。</li><li> 其他：将来在 Linux 上部署 Kafka 之后，采用后台运行的方式，就会避免这样的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to My HomePage!</title>
      <link href="/2023/03/05/hello-world/"/>
      <url>/2023/03/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 下安装 Node.js 避坑指南</title>
      <link href="/2023/03/05/macos_nodejs/"/>
      <url>/2023/03/05/macos_nodejs/</url>
      
        <content type="html"><![CDATA[<ul><li><p>不建议的方法：直接到 Node 官网下载 <code>.pkg</code> 文件进行安装。</p></li><li><p>可能出现的问题：使用 <code>npm install -g hexo-cli</code> 等指令会报错没有写入的权限，甚至尝试各种 <code>sudo</code> 权限都无效。</p></li><li><p>npm 官网教程也不推荐采用 <code>installer</code> 进行安装。</p></li></ul><h2 id="安装 Node-js 和 npm 的正确方法"><a href="# 安装 Node-js 和 npm 的正确方法" class="headerlink" title="安装 Node.js 和 npm 的正确方法"></a>安装 Node.js 和 npm 的正确方法 </h2><p>🌟 使用 node 版本管理工<code>nvm</code>(node version manager) 安装 Node.js 和 npm。</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>安装<code>nvm</code>：</p><pre><code>~$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</code></pre><p>验证 <code>nvm</code> 是否安装成功：</p><pre><code>~$ command -v nvm</code></pre><p>若成功则出现一行 <code>nvm</code> 字符 (若未出现则重启<code>terminal</code>)，查询<code>nvm</code> 版本：</p><pre><code>~$ nvm --version</code></pre><p>返回 <code>nvm</code> 版本号：<code>0.34.0</code></p><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>使用 <code>nvm</code> 安装<code>node</code>：</p><pre><code>~$ nvm install node # &quot;node&quot; is an alias for the latest version</code></pre><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>使用 <code>npm</code> 指令安装<code>hexo</code>：</p><pre><code>~$ npm install -g hexo-cli</code></pre><p>初始化<code>hexo</code>，指定文件夹名为 blog：</p><pre><code>~$ hexo init blog</code></pre><p>进入 blog 文件夹下，安装<code>npm</code>：</p><pre><code>~ $ cd blog~ $ npm istall</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>Q1：<code>zsh: command not found: nvm</code></p><p>A1：进入 .nvm 文件夹，查看是否存在 .bash_profile 文件，若存在该文件则直接打开：</p><pre><code>cd ~/.nvmopen .bash_profile</code></pre><p>若不存在则先创建 .bash_profile 文件：</p><pre><code>touch .bash_profile</code></pre><p>然后在 .bash_profile 文件内写入：</p><pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;[-s &quot;$NVM_DIR/nvm.sh&quot;] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</code></pre><p>写入完毕后，关闭文件，执行 .bash_profile 文件：</p><pre><code>source .bash_profile</code></pre><p>Q2：每次关闭 <code>terminal</code> 后，又出现 <code>zsh: command not found: nvm</code> 等无法找到某指令的情况，需要重新执行 .bash_profile 文件。</p><p>A2：原因是采用的 <code>terminal</code> 是<code>zsh</code>，需要将配置添加到 .zshrc 文件中。</p><p>打开  .zshrc 文件：</p><pre><code>open ~/.zshrc</code></pre><p>在 .zshrc 文件内写入：</p><pre><code>export NVM_DIR=~/.nvm[-s &quot;$NVM_DIR/nvm.sh&quot;] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;</code></pre><p>写入完毕后，关闭文件，执行 .zshrc 文件：</p><pre><code>source ~/.zshrc</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式 NoSQL 数据库 Redis</title>
      <link href="/2023/03/01/Redis/"/>
      <url>/2023/03/01/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Redis- 基础"><a href="#1-Redis- 基础" class="headerlink" title="1. Redis 基础"></a>1. Redis 基础</h1><h2 id="1-1- 简介"><a href="#1-1- 简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Redis 是一个基于 C 语言开发的开源数据库，区别于传统数据库，其数据存储于内存之中 (内存数据库)。</p><h2 id="1-2- 特点"><a href="#1-2- 特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ul><li><p>读写速度快 (缓存)</p></li><li><p>存储 key - value 键值对数据</p></li></ul><h2 id="1-3- 数据结构"><a href="#1-3- 数据结构" class="headerlink" title="1.3 数据结构"></a>1.3 数据结构</h2><ul><li>五种基础数据结构：<ul><li>String</li><li>List</li><li>Hash</li><li>Set</li><li>Zset</li></ul></li><li>三种特殊数据结构：<ul><li>HyperLogLog</li><li>Bitmap</li><li>Geospatial</li></ul></li></ul><h2 id="1-4- 应用场景"><a href="#1-4- 应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h2><ul><li>事务</li><li>持久化</li><li>Lua 脚本</li><li>开箱即用的集群方案 (Redis Sentinel、Redis Cluster) 等</li></ul><h2 id="1-5-Redis- 为什么快？"><a href="#1-5-Redis- 为什么快？" class="headerlink" title="1.5 Redis 为什么快？"></a>1.5 Redis 为什么快？</h2><ul><li>基于内存，内存的访问速度远超磁盘；</li><li>基于 Reactor 设计模式，采用单线程架构和 IO 多路复用；</li><li>内置了多种优化后的数据结构实现，性能高。</li></ul><h1 id="2-Redis- 与 -Memcached- 的异同点"><a href="#2-Redis- 与 -Memcached- 的异同点" class="headerlink" title="2. Redis 与 Memcached 的异同点"></a>2. Redis 与 Memcached 的异同点</h1><ul><li>共同点<ul><li>均基于内存，一般用作缓存；</li><li>均有过期策略；</li><li>均性能较高。</li></ul></li><li>不同点<ul><li>Redis 支持更丰富的数据类型即可用的场景更多；</li><li>Redis 支持数据持久化，将内存的数据保持在磁盘中，重启时可以再次加载使用，Memcached 则将所有数据存于内存之中；</li><li>Redis 有灾难恢复机制，可以将缓存中的数据持久化到磁盘上；</li><li>Redis 在服务器内存使用完后将不用的数据放到磁盘上，Memcached 在服务器内存使用完后会报异常；</li><li>Redis 原生支持 cluster 模式，Memcached 无原生的集群模式，依赖于客户端实现集群中分片写入数据；</li><li>Redis 采用单线程的多路 IO 复用模型，Mencached 则是多线程的；</li><li>Redis 支持发布 - 订阅模式、Lua 脚本、事务等功能，Memcached 则不支持；</li><li>Redis 同时使用惰性删除和定期删除，Memcached 过期数据的删除策略只用了惰性删除。</li></ul></li></ul><h1 id="3- 为什么要用 -Redis- 缓存 -？"><a href="#3- 为什么要用 -Redis- 缓存 -？" class="headerlink" title="3. 为什么要用 Redis ( 缓存)？"></a>3. 为什么要用 Redis (缓存)？</h1><ul><li><p>高性能</p><ul><li>将用户经常访问的、不经常变更的高频数据存入缓存，相较于每次从硬盘读取数据要快得多。</li></ul></li><li><p>高并发</p><ul><li>采用 Redis 缓存的 QPS 高于 MySQL，使用 Redis 集群则会更高。将数据库中的部分数据转移到缓存中去，可以使得用户的部分请求不需要经过数据库而是直接从缓存中读取，从而提高整体的并发行。</li></ul></li></ul><h1 id="4-Redis- 的用途"><a href="#4-Redis- 的用途" class="headerlink" title="4. Redis 的用途"></a>4. Redis 的用途 </h1><p> 除了用作缓存意外以外，Redis 还可以用作：</p><ul><li>分布式锁：一般基于 Redisson 实现；</li><li>限流：一般通过 Redis + Lua 脚本的方式实现；</li><li>消息队列：自带的 list 可用作消息队列，Redis 5.0 新增的 Stream 类型的数据结构更适合用作消息队列，且支持消息持久化和 ACK 机制；</li><li>复杂业务场景：通过 bitmap 统计活跃用户，通过 sorted set 维护排行榜。</li></ul><h1 id="5-Redis-5-0- 新增的 -Stream"><a href="#5-Redis-5-0- 新增的 -Stream" class="headerlink" title="5. Redis 5.0 新增的 Stream"></a>5. Redis 5.0 新增的 Stream</h1><p>新增的数据结构 Stream 支持：</p><ul><li>发布 - 订阅模式；</li><li>按照消费者组进行消费；</li><li>消息持久化 (RDB、AOF)。</li></ul><h1 id="6-Redis- 单线程模型"><a href="#6-Redis- 单线程模型" class="headerlink" title="6. Redis 单线程模型"></a>6. Redis 单线程模型</h1><p>Redis 基于 Reactor 设计模式开发了一套高效的事件处理模型，对应 Redis 中的文件事件处理器 (file event handler) ，该处理器是单线程的，因此一般说 Redis 是单线程模型。文件事件处理器以单线程方式运行，但是通过使用 I&#x2F;O 多路复用程序监听多个套接字，既实现了高性能的网络通信模型，又可以与 Redis 中的其他单线程模块对接，保持了 Redis 内部单线程设计的简单性。</p><ul><li>文件事件处理器 file event handler 的四个主要组成部分：<ul><li>多个 socket (客户端连接)</li><li>IO 多路复用程序 (支持多个客户端连接的关键)</li><li>文件事件分派器 (将 socket 关联到相应的事件处理器)</li><li>事件处理器 (连接应答处理器、命令请求处理器、命令回复处理器 、主从连接处理器)</li></ul></li></ul><h1 id="7- 过期数据的删除策略"><a href="#7- 过期数据的删除策略" class="headerlink" title="7. 过期数据的删除策略"></a>7. 过期数据的删除策略</h1><ul><li>惰性删除：仅在取出 key 的时候对数据进行过期检测，但可能造成过多的过期 key 未被删除。</li><li>定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ul><p>惰性删除对 CPU 友好，定期删除对内存友好，因此 Redis 采用定期删除 + 惰性删除 &#x2F; 懒汉式删除，同时结合内存淘汰机制。</p><h1 id="8-Redis- 持久化机制"><a href="#8-Redis- 持久化机制" class="headerlink" title="8. Redis 持久化机制"></a>8. Redis 持久化机制</h1><h2 id="8-1-RDB- 持久化"><a href="#8-1-RDB- 持久化" class="headerlink" title="8.1 RDB 持久化"></a>8.1 RDB 持久化</h2><p>RDB 持久化即快照持久化 (snapshooting)，Redis 通过创建快照来获得存储在内存中的数据在某个时间点上的副本。由于 Redis 具有主从结构，在其创建快照后，可以将快照备份至其他服务器即创建副本。</p><h2 id="8-2-AOF- 持久化"><a href="#8-2-AOF- 持久化" class="headerlink" title="8.2 AOF 持久化"></a>8.2 AOF 持久化</h2><p>AOF (append only file) 持久化，相比快照持久化具有更好的实时性。开启 AOF 持久化方式后，每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存中，然后根据配置来决定何时将其同步到硬盘中的 AOF 文件中。Redis AOF 持久化机制在执行完命令后再记录日志。</p><h1 id="9-Redis- 事务"><a href="#9-Redis- 事务" class="headerlink" title="9. Redis 事务"></a>9. Redis 事务 </h1><p>Redis 通过 <code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code> 等命令实现事务。</p><p>实现 Redis 事务流程：</p><ul><li>开始事务 (MULTI)；</li><li>命令入队：批量操作 Redis 命令，按照 FIFO 的顺序执行；</li><li>执行事务 (EXEC)。</li></ul><h1 id="10- 缓存穿透"><a href="#10- 缓存穿透" class="headerlink" title="10. 缓存穿透"></a>10. 缓存穿透 </h1><p> 当客户端向服务器发送大量读请求时，由于 Redis 缓存中没有对应的数据，大量读请求落到数据库上，但数据库也没有对应的数据，导致“缓存穿透”。</p><p>注：此处大量读请求的 key 是不合理的。 </p><p>🌟 解决方法：</p><ul><li>缓存无效 key</li><li>布隆过滤器</li></ul><h1 id="11- 缓存击穿"><a href="#11- 缓存击穿" class="headerlink" title="11. 缓存击穿"></a>11. 缓存击穿 </h1><p> 当客户端向服务器发送大量读请求时，由于 Redis 缓存中没有对应的数据 (可能已经过期了)，大量读请求落到数据库中 (虽然数据库中存在该数据但是 Redis 缓存中没有该数据)，导致“缓存击穿”。</p><p>注：此处大量读请求的 key 对应热点数据。</p><p>🌟 解决方法：</p><ul><li>设置热点数据永不过期 &#x2F; 过期时间较长；</li><li>针对热点数据提前预热，将其存入缓存并设置合理的过期时间；</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求落到数据库上，减轻数据库的压力。</li></ul><h1 id="12- 缓存雪崩"><a href="#12- 缓存雪崩" class="headerlink" title="12. 缓存雪崩"></a>12. 缓存雪崩 </h1><p> 当客户端向服务器发送大量读请求时，由于 Redis 缓存中对应的大量数据同时过期，大量读请求落到数据库上 (数据库中存在对应的数据)，导致“缓存雪崩”。</p><p>🌟 解决方法：</p><ol><li>针对 Redis 服务不可用情况：</li></ol><ul><li>采用 Redis 集群，避免单机出现问题导致整个缓存服务都没法使用；</li><li>限流，避免同时处理大量的请求。</li></ul><ol start="2"><li>针对热点缓存失效情况：</li></ol><ul><li>设置不同的失效事件，例如随机设置缓存的失效时间；</li><li>缓存永不失效，不推荐；</li><li>设置二级缓存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 算法笔记之链表 (双指针解法)</title>
      <link href="/2023/03/01/linkedlist/"/>
      <url>/2023/03/01/linkedlist/</url>
      
        <content type="html"><![CDATA[<p>🌟 LeetCode 算法笔记之链表，复习整理双指针解决链表题目。</p><h1 id="141- 环形链表"><a href="#141- 环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表 </h1><p><a href="https://leetcode.cn/problems/linked-list-cycle/"> 题源：141. Linked List Cycle</a></p><blockquote><p>给你一个链表的头结点 head ，判断链表中是否有环。</p><p>如果链表中有某个结点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置双指针，慢指针 slow 每次前进一步，快指针 fast 每次前进两步。</li><li>如果 fast 最终遇到空指针，说明链表中没有环。</li><li>如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        ListNode fast = head, slow = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;            if (fast == slow) return true;        &#125;        return false;    &#125;&#125;</code></pre><h1 id="142- 环形链表 -II"><a href="#142- 环形链表 -II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">题源：142. Linked List Cycle II</a></p><blockquote><p>给定一个链表的头结点  head ，返回链表开始入环的第一个结点。 如果链表无环，则返回 null。</p><p>如果链表中有某个结点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p></blockquote><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ol><li>原理：</li></ol><ul><li><p>当快、慢指针分别以 2v、v 的速度前进并第一次相遇时：</p><ul><li><p>如果慢指针走了 k 步，则快指针一定走了 2k 步。</p></li><li><p>快指针比慢指针多走的 k 步，其实就是快指针在环内转圈，即 k 值为环长度的 <em>整数倍</em>。</p></li><li><p>假设相遇点 M 距离环的起点 C 的距离为 m，则慢指针从头结点 H 到环的起点 C 的移动距离 HC 为 <code>k - m</code>。</p></li><li><p>也就是说如果快、慢指针在相遇点 M 时，重置慢指针，让慢指针再次从头结点 H 出发，前进 <code>k - m</code> 步即可到达环的起点 C。</p></li><li><p>此时，如果快指针从相遇点继续前进，且速度和慢指针保持一致都为 v，恰巧也需前进 <code>k - m</code> 步即可到达环的起点 C。</p></li></ul></li></ul><ol start="2"><li>解法：</li></ol><ul><li>设置双指针，慢指针 slow 每次前进一步，快指针 fast 每次前进两步。</li><li>当快、慢指针相遇时：<ul><li>让其中一个指针指向头结点；</li><li>此时，设置快、慢指针前进速度一致，均每次前进一步。</li></ul></li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><ul><li>第一个 while 循环是为了寻找相遇点 M。</li><li>第二个 while 循环是为了重置慢指针到头结点，并寻找两个指针最终的位置即环起点。</li></ul><pre><code class="java">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        ListNode fast = head, slow = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;            if (slow == fast) break;        &#125;        if (fast == null || fast.next == null) return null;        slow = head;        while (slow != fast) &#123;            fast = fast.next;            slow = slow.next;        &#125;        return slow;    &#125;&#125;</code></pre><h1 id="160- 相交链表"><a href="#160- 相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表 </h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/"> 题源：160. 相交链表</a></p><blockquote><p>给你两个单链表的头结点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始结点。如果两个链表不存在相交结点，返回 <code>null</code> 。</p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意 </strong>，函数返回结果后，链表必须 <strong> 保持其原始结构</strong> 。</p></blockquote><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置两个指针 p1 和 p2，分别指向 链表 A 和链表 B 的头结点。</li><li>让指针 p1 和 p2 分别在在两条链表上遍历：<ul><li>当指针 p1 遍历完链表 A 后，开始遍历链表 B；</li><li>当指针 p2 遍历完链表 B 后，开始遍历链表 A；</li><li>在逻辑上，两条链表“连接成了一条链表”。</li></ul></li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        ListNode p1 = headA, p2 = headB;        while (p1 != p2) &#123;            if (p1 != null) &#123;                p1 = p1.next;            &#125; else &#123;                p1 = headB;            &#125;            if (p2 != null) &#123;                p2 = p2.next;            &#125; else &#123;                p2 =headA;            &#125;        &#125;        return p1;    &#125;&#125;</code></pre><h1 id="19- 删除链表的倒数第 -N- 个结点"><a href="#19- 删除链表的倒数第 -N- 个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点 </h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/"> 题源：19. 删除链表的倒数第 N 个结点</a></p><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p></blockquote><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><ul><li>要删除链表的倒数第 n 个结点，则需要获得倒数第 n + 1 个结点的引用。</li><li>设置指针 p1 和 p2，首先让指针 p1 指向链表的头结点，并向前移动 k 步；</li><li>此时，让指针 p2 指向链表的头结点，并让两个指针 p1 和 p2 同时向前移动；</li><li>当指针 p1 移动至链表末尾的空指针时，其移动的第二段长度为 <code>n - k</code> 步，而此时指针 p2 也移动了 <code>n - k</code>步，位于链表的倒数第 k 个结点。</li></ul><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><ul><li>方法 <code>findFromEnd()</code> ：返回链表的倒数第 k 个结点。</li><li>结点 x 用于存储链表的倒数第 n + 1 个结点</li></ul><p>🌟 在链表的头部添加一个虚拟结点 dummy：可以避免删除倒数第一个元素时出现空指针异常。</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(-1);        dummy.next = head;        // 删除倒数第 n 个，要先找倒数第 n + 1 个结点        ListNode x = findFromEnd(dummy, n + 1);        x.next = x.next.next;        return dummy.next;    &#125;    // 返回链表的倒数第 k 个结点    private ListNode findFromEnd(ListNode head, int k) &#123;        ListNode p1 = head;        for (int i = 0; i &lt; k; i++) &#123;            p1 = p1.next;        &#125;        ListNode p2 = head;        while (p1 != null) &#123;            p1 = p1.next;            p2 = p2.next;        &#125;        return p2;    &#125;&#125;</code></pre><h1 id="21- 合并两个有序链表"><a href="#21- 合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表 </h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/"> 题源：21. 合并两个有序链表</a></p><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。 </p></blockquote><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置两个指针 p1 和 p2，分别指向链表的两个头结点。</li><li>让指针 p1 和 p2 分别在两个链表上遍历，每次都比较两个指针所指向的结点的值：<ul><li>若指针 p1 指向的结点值小于指针 p2 指向的结点值，则将指针 p1 指向的结点加入到新合并的链表中，并将指针 p1 往前移动一步；</li><li>若指针 p1 指向的结点值大于指针 p2 指向的结点值，则将指针 p2 指向的结点加入到新合并的链表中，并将指针 p2 往前移动一步；</li></ul></li></ul><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><p>🌟 在链表的头部添加一个虚拟结点 dummy：可以避免出现空指针异常、简化代码。</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode dummy = new ListNode(-1);        ListNode p = dummy;        ListNode p1 = list1, p2 = list2;        while (p1 != null &amp;&amp; p2 != null) &#123;            if (p1.val &gt; p2.val) &#123;                p.next = p2;                p2= p2.next;            &#125; else &#123;                p.next = p1;                p1= p1.next;            &#125;            p = p.next;        &#125;        if (p1 != null) p.next = p1;        if (p2 != null) p.next = p2;        return dummy.next;    &#125;&#125;</code></pre><h1 id="23- 合并 -K- 个升序链表"><a href="#23- 合并 -K- 个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表 </h1><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/"> 题源：23. 合并 K 个升序链表</a></p><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><ul><li>采用优先队列 <code>PriorityQueue</code> 实现小顶堆。</li><li>将 k 个链表的头结点加入到最小堆中：<ul><li>当优先队列不为空时，每次获取最小结点，加入到结果链表中。</li></ul></li></ul><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><ul><li><code>PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(lists.length, (a, b)-&gt;(a.val - b.val));</code>采用 lambda 表达式实现小顶堆。</li><li>设置虚拟头结点 dummy。</li></ul><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode mergeKLists(ListNode[] lists) &#123;        if (lists.length == 0) return null;        ListNode dummy = new ListNode(-1);        ListNode p = dummy;        PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(lists.length, (a, b)-&gt;(a.val - b.val)        );        for (ListNode head : lists) &#123;            if (head != null) &#123;                pq.add(head);            &#125;        &#125;        while (!pq.isEmpty()) &#123;            ListNode node = pq.poll();            p.next = node;            if (node.next != null) &#123;                pq.add(node.next);            &#125;            p = p.next;        &#125;        return dummy.next;    &#125;&#125;</code></pre><h1 id="86- 分隔链表"><a href="#86- 分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表 </h1><p><a href="https://leetcode.cn/problems/partition-list/"> 题源：86. 分隔链表</a></p><blockquote><p>给你一个链表的头结点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的结点都出现在 大于或等于 x 的结点之前。</p><p>你应当 保留 两个分区中每个结点的初始相对位置。</p></blockquote><h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置两个虚拟头结点 dummy1 和 dummy2，设置两个指针 p1 和 p2，让两个指针分别指向两个 dummy 结点。</li><li>遍历给定的链表，判断每个遍历的结点：<ul><li>如果当前结点的值小于给定的数值 x，将该结点接到 dummy1 结点所在链表，并将指针 p1 向前移动一步；</li><li>如果当前结点的值大于给定的数值 x，将该结点接到 dummy2 结点所在链表，并将指针 p2 向前移动一步。</li><li>进入下一个循环进行判断。</li></ul></li><li>将 dummy2 所在链表拼接到 dummy1 所在链表之前，并将尾结点的后继结点设为 null。</li></ul><p>🌟 <code>p2.next = null;</code>是关键，没写可能导致超出内存限制。 </p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;                ListNode dummy1 = new ListNode(-1);          ListNode dummy2 = new ListNode(-1);          ListNode p1 = dummy1;          ListNode p2 = dummy2;          while (head != null) &#123;              if (head.val &lt; x) &#123;                    p1.next = head;                  p1 = p1.next;              &#125; else &#123;                  p2.next = head;                  p2 = p2.next;            &#125;              head = head.next;        &#125;          p1.next = dummy2.next;          p2.next = null;          return dummy1.next;    &#125;&#125;</code></pre><h1 id="876- 链表的中间结点"><a href="#876- 链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点 </h1><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/"> 题源：876. 链表的中间结点</a></p><blockquote><p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p></blockquote><h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><ul><li>设置快、慢指针向前移动的速度分别为 2v、v。</li><li>快指针每次移动两步，慢指针每次移动一步，当快指针移动到链表末尾时，慢指针恰好位于链表中点。</li></ul><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode middleNode(ListNode head) &#123;        ListNode fast = head, slow = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        return slow;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
